<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta http-equiv="Content-Style-Type" content="text/css" />
        <meta name="generator" content="pandoc" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                        <title></title>
        <style type="text/css">code{white-space: pre;}</style>
                            <style type="text/css">
            div.sourceCode { overflow-x: auto; }
            table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
              margin: 0; padding: 0; vertical-align: baseline; border: none; }
            table.sourceCode { width: 100%; line-height: 100%; }
            td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
            td.sourceCode { padding-left: 5px; }
            code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
            code > span.dt { color: #902000; } /* DataType */
            code > span.dv { color: #40a070; } /* DecVal */
            code > span.bn { color: #40a070; } /* BaseN */
            code > span.fl { color: #40a070; } /* Float */
            code > span.ch { color: #4070a0; } /* Char */
            code > span.st { color: #4070a0; } /* String */
            code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
            code > span.ot { color: #007020; } /* Other */
            code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
            code > span.fu { color: #06287e; } /* Function */
            code > span.er { color: #ff0000; font-weight: bold; } /* Error */
            code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
            code > span.cn { color: #880000; } /* Constant */
            code > span.sc { color: #4070a0; } /* SpecialChar */
            code > span.vs { color: #4070a0; } /* VerbatimString */
            code > span.ss { color: #bb6688; } /* SpecialString */
            code > span.im { } /* Import */
            code > span.va { color: #19177c; } /* Variable */
            code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
            code > span.op { color: #666666; } /* Operator */
            code > span.bu { } /* BuiltIn */
            code > span.ex { } /* Extension */
            code > span.pp { color: #bc7a00; } /* Preprocessor */
            code > span.at { color: #7d9029; } /* Attribute */
            code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
            code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
            code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
            code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
            </style>
                                            <style>
            body {
                font-family: Georgia;
                max-width: 800px;
                margin: 0 auto;
                line-height: 30px;
                font-size: 18px;
                padding-left: 350px;
                padding-right: 50px;
                color: #111;
            }
            
            h1, h2, h3, h4, h5, h6 {
                font-family: Arial;
            }
            
            h1 {
                padding-top: 200px;
                line-height: 50px;
            }
            h2 {
                padding-top: 30px;
            }
            h3 {
                padding-top: 20px;
            }
            h4 {
                padding-top: 10px;
            }
            p {
                text-align: justify;
            }
            p a {
                word-wrap: break-word;
                white-space: pre;
            }
            code {
                word-wrap: break-word;
            }
            blockquote {
                border-left: 3px solid #eee;
                margin-left: 20px;
                padding-left: 20px;
            }
            
            ::selection {
                background-color: #E4E4E4;
            }
            
            table {
                width: 100%;
            }
            table caption {
                font-weight: bold;
            }
            table tr {
                padding: 0;
                margin: 0;
                background-color: #f0f0f0;
            }
            table tr.even {
                background-color: #fafafa;
            }
            table td {
                margin: 0;
                padding: 3px 5px;
            }
            
            p span.added {
                color: green;
                background-color: #FFF3C5;
            }
            p span.removed {
                color: red;
                background-color: #FFF3C5;
            }
            
            #title-page {
                padding: 80px 0;
            }
            
            #TOC {
                position: fixed;
                left: 0;
                top: 0;
                overflow-y: scroll;
                height: 100%;
                background: #fafafa;
                max-width: 300px;
                font-family: Arial;
                font-size: 15px;
                line-height: 30px;
            }
            ::-webkit-scrollbar {
                width: 8px;
            }
            ::-webkit-scrollbar-track {
                background-color: #ECECEC;
            }
            ::-webkit-scrollbar-thumb {
                background-color: #B0B0B0;
                border-radius: 8px;
            }
            #TOC > ul {
                padding-right: 10px;
            }
            #TOC ul {
                list-style: none;
                padding-left: 20px;
            }
            #TOC ul li a {
                text-decoration: none;
                color: #364149;
                text-overflow: ellipsis;
                display: block;
                white-space: nowrap;
                overflow: hidden;
            }
            #TOC ul li a:hover {
                color: #008cff;
            }
            
            .figure {
                text-align: center;
            }
            .figure p {
                text-align: center;
                font-style: italic;
            }
            .figure img {
                  width: 100%;
            }
            </style>
                <script src="js/jquery.js"></script>
        <script src="js/diff.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
                <!--
                -->
        <div id="title-page">
            <h1>This is the title of the thesis</h1>
            <h2>Firstname Surname</h2>
        </div>
                    <div id="TOC">
                <ul>
                <li><a href="#bevezetés"><span class="toc-section-number">1</span> Bevezetés</a></li>
                <li><a href="#rendszer-áttekintés"><span class="toc-section-number">2</span> Rendszer áttekintés</a><ul>
                <li><a href="#eszközök"><span class="toc-section-number">2.1</span> Eszközök</a><ul>
                <li><a href="#szenzorok"><span class="toc-section-number">2.1.1</span> Szenzorok</a></li>
                <li><a href="#aktorok"><span class="toc-section-number">2.1.2</span> Aktorok</a></li>
                </ul></li>
                <li><a href="#hálózati-réteg"><span class="toc-section-number">2.2</span> Hálózati réteg</a></li>
                <li><a href="#központi-szerver"><span class="toc-section-number">2.3</span> Központi szerver</a><ul>
                <li><a href="#flow-rendszer"><span class="toc-section-number">2.3.1</span> Flow-rendszer</a></li>
                <li><a href="#statisztika"><span class="toc-section-number">2.3.2</span> Statisztika</a></li>
                <li><a href="#kezelőpanel"><span class="toc-section-number">2.3.3</span> Kezelőpanel</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#eszközök-1"><span class="toc-section-number">3</span> Eszközök</a><ul>
                <li><a href="#hardver-választás"><span class="toc-section-number">3.1</span> Hardver választás</a><ul>
                <li><a href="#arduino"><span class="toc-section-number">3.1.1</span> Arduino</a></li>
                <li><a href="#vezetéknélküli-modulok"><span class="toc-section-number">3.1.2</span> Vezetéknélküli modulok</a></li>
                <li><a href="#eszköz-specifikus-hardver"><span class="toc-section-number">3.1.3</span> Eszköz specifikus hardver</a></li>
                </ul></li>
                <li><a href="#felépítés"><span class="toc-section-number">3.2</span> Felépítés</a><ul>
                <li><a href="#példák-kész-eszközökre"><span class="toc-section-number">3.2.1</span> Példák kész eszközökre</a></li>
                </ul></li>
                <li><a href="#firmware-működés"><span class="toc-section-number">3.3</span> Firmware működés</a><ul>
                <li><a href="#megszakítások"><span class="toc-section-number">3.3.1</span> Megszakítások</a></li>
                <li><a href="#alacsony-fogyasztás"><span class="toc-section-number">3.3.2</span> Alacsony fogyasztás</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#hálózati-réteg-1"><span class="toc-section-number">4</span> Hálózati réteg</a><ul>
                <li><a href="#mesh-hálózat"><span class="toc-section-number">4.1</span> Mesh hálózat</a><ul>
                <li><a href="#felépítés-1"><span class="toc-section-number">4.1.1</span> Felépítés</a></li>
                <li><a href="#címzés"><span class="toc-section-number">4.1.2</span> Címzés</a></li>
                </ul></li>
                <li><a href="#üzenetek-felépítése"><span class="toc-section-number">4.2</span> Üzenetek felépítése</a><ul>
                <li><a href="#kommunikáció-a-központi-szerverrel"><span class="toc-section-number">4.2.1</span> Kommunikáció a központi szerverrel</a></li>
                <li><a href="#kommunikáció-az-eszközökkel"><span class="toc-section-number">4.2.2</span> Kommunikáció az eszközökkel</a></li>
                </ul></li>
                <li><a href="#raspberry-pi"><span class="toc-section-number">4.3</span> Raspberry Pi</a><ul>
                <li><a href="#használat"><span class="toc-section-number">4.3.1</span> Használat</a></li>
                <li><a href="#raspberry-pi-foundation"><span class="toc-section-number">4.3.2</span> Raspberry Pi Foundation</a></li>
                </ul></li>
                <li><a href="#szoftver-működés"><span class="toc-section-number">4.4</span> Szoftver működés</a><ul>
                <li><a href="#programkönyvtárak"><span class="toc-section-number">4.4.1</span> Programkönyvtárak</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#központi-rendszer"><span class="toc-section-number">5</span> Központi rendszer</a><ul>
                <li><a href="#adatbázis"><span class="toc-section-number">5.1</span> Adatbázis</a><ul>
                <li><a href="#adatbázis-kezelő-rendszer-kiválasztása"><span class="toc-section-number">5.1.1</span> Adatbázis-kezelő rendszer kiválasztása</a></li>
                <li><a href="#tárolási-séma"><span class="toc-section-number">5.1.2</span> Tárolási séma</a></li>
                </ul></li>
                <li><a href="#keretrendszerek"><span class="toc-section-number">5.2</span> Keretrendszerek</a><ul>
                <li><a href="#spring-boot"><span class="toc-section-number">5.2.1</span> Spring Boot</a></li>
                <li><a href="#vaadin"><span class="toc-section-number">5.2.2</span> Vaadin</a></li>
                </ul></li>
                <li><a href="#flow-rendszer-1"><span class="toc-section-number">5.3</span> Flow rendszer</a><ul>
                <li><a href="#flow-végrehajtás"><span class="toc-section-number">5.3.1</span> Flow végrehajtás</a></li>
                <li><a href="#flow-létrehozás"><span class="toc-section-number">5.3.2</span> Flow létrehozás</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#összefoglalás"><span class="toc-section-number">6</span> Összefoglalás</a></li>
                <li><a href="#köszönetnyilvánítás">Köszönetnyilvánítás</a></li>
                <li><a href="#irodalomjegyzék">Irodalomjegyzék</a></li>
                </ul>
            </div>
                                

<p> </p>


<h1 id="bevezetés"><span class="header-section-number">1</span> Bevezetés</h1>
<p>Dolgozatom témaválasztása nem volt nehéz feladat számomra, mivel korábbi érdeklődés alapján már találkoztam az otthon &quot;okosítás&quot; vagy automatizálás témakörével. Rendkívül le tudtak foglalni a hardverközeli, mikrokontrollereket felhasználó projektjeim és azoknak kapcsán kezdtem el például különböző környezeti jellemző mérőeszközöket készíteni szabadidőmben. Onnantól kezdve pedig rövid út vezet házak utólagos felokosításának ötletéhez. Foglalkoztat még az is, hogy milyen előnyei lehetnek egy okos otthon rendszernek. Természetesen az elsődleges dolog e szempontból a spórolás lehetősége. Mindenki szeretne lefaragni a számlák összegéből például a fűtés kikapcsolásával, mikor nem vagyunk otthon, vagy a lámpák automatikus lekapcsolásával, ha éppen nem vagyunk a szobában. Másik vonzó tulajdonsága egy okos otthonnak, hogy rengeteg kényelmi funkciót tud nyújtani. Gomb nyomásra leengedhetjük a ház összes sötétítőjét vagy a rendszer meglocsolhatja helyettünk a növényeket. Tervem, hogy ezt az általam fejlesztett rendszert a saját otthonomban használjam jelentős számú mérőeszközöket felhasználva.</p>
<p>Annak a háttérében, hogy mindezt a Java nyelv segítségével tervezem megvalósítani, szintén egyszerű okok állnak. Tanulmányaim során legtöbbször a Java nyelvvel találkozhattam és így szerezhettem jelentősebb belelátást a működésébe és használatába. Így mivel szinte egyedül a Java nyelvhez kapcsolódóan van megfelelő tudásom ahhoz, hogy szakdolgozathoz illő nagyságú munkát készítsek, azt választottam alapnak. Másik fontos oka választásomnak, hogy szakmai gyakorlatom alatt is Java nyelvet használtam és így tudtam ismereteket szerezni több olyan keretrendszerről, amiket használni is szeretnék tapasztalatszerzés céljából, illetve pontosan beleilletek a bennem kialakuló képbe, amit arról a rendszerről alkottam, mely ennek a dolgozatnak az alapját adja.</p>
<p>A dolgozatom során a fő cél egy olyan rendszer elkészítése, mely képes apró eszközök és egy központi egység segítségével automatizált feladatokat elvégezni. Ennek eléréséhez meg kellett tervezni az apró eszközök hardveres felépítését, fejleszteni egy központi szoftvert, ami képes az eszközöktől érkező adatok feldolgozására és azok alapján a felhasználó által megadott szabályok mentén feladatokat végrehajtására. Felmerült több érdekes kérdés is, melyekre kutatásaim során találtam válaszokat és próbáltam ezen válaszokat felhasználni a fejlesztés során.</p>
<p>A fejlesztés alatt végig úgy hoztam a döntéseket, hogy egy egyszerű háztartásban kell működjön a rendszer. Tehát nem volt célom az, hogy nagy számú felhasználók használják egyszerre vagy éppen több száz eszköz kapcsolódjon a központi rendszerhez. Részletesebben és feladathoz kapcsolódóan is meg fogom fogalmazni az elvárásokat, célokat a rendszerrel szemben, de ezt természetesen a későbbi fejezetekben teszem majd.</p>
<h1 id="rendszer-áttekintés"><span class="header-section-number">2</span> Rendszer áttekintés</h1>
<p>Ebben a fejezetben egy kezdeti képet szeretnék adni a teljes rendszer alapvető felépítéséről, illetve arról, hogy az egyes rendszer részek felé milyen elvárások vannak. Minden részt kifejtek ebben a fejezetben, de csak annyira, hogy átláthatóvá tegye a dolgozat többi részét. Későbbi fejezetekben viszont majd mélyrehatóbban nézzük meg a rendszer alapjait.</p>
<p>Alapvetően három részre bontható a rendszer:</p>
<ul>
<li>Eszközök, amely magába foglalja az összes mérőeszközt és egyéb kisebb beágyazott rendszereket. Ezek egyszerű mikrokontrollereket használó rendszerek, amiknek annyi szerepe van, hogy vagy adatot szolgáltatnak, vagy valamilyen funkcionalitást végeznek el.</li>
<li>Hálózati réteg, amely egy egyszerű közvetítőként funkcionál a központi szerver és az eszközök között. Lényegében átalakítja az üzeneteket a két rész között a megfelelő formátumra.</li>
<li>Központi szerver, amely végzi az adatok feldolgozását és biztosít egy felületet a felhasználó számára, hogy láthassa a rendszer állapotát vagy aktuális adatokat.</li>
</ul>

<h2 id="eszközök"><span class="header-section-number">2.1</span> Eszközök</h2>
<p>Mint már említve volt, ide tartoznak azok a hardverközeli rendszerek, amik vagy adatgyűjtő szerepet töltenek be, vagy valamilyen funkcionalitást képesek végrehajtani. Lehet egy ilyen eszköz például egy hőmérő, légnyomásmérő, földnedvességmérő vagy éppen egy relé.</p>
<p>Ezek az eszközök két csoportba sorolhatók:</p>
<ul>
<li>Érzékelők, másnéven <em>szenzorok</em> vagy</li>
<li>Cselekvők, másnéven <em>aktorok</em><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></li>
</ul>
<p>Valójában viszont ez a két csoport nem diszjunkt és később kiderül miért is nem, ha látjuk pontosan melyik mit jelent. Közös bennük, hogy mindegyikben van egy mikrokontroller és egy kommunikációért felelős modul. E mellett mindegyik eszköz tartalmaz még egy specifikus modult is, ami meghatározza, hogy mit is csinál az adott eszköz (pl.: hőmérő esetén egy hőmérséklet- és páratartalom érzékelő), illetve, hogy melyik csoportba tartozik.</p>
<h3 id="szenzorok"><span class="header-section-number">2.1.1</span> Szenzorok</h3>
<p>Magától értetődően a szenzorok felelősek az adatok szolgáltatásáért. Működését tekintve a mikrokontroller vezérli az adatgyűjtés és küldés folyamatát. Az idő nagy részében alvó állapotban van energiatakarékossági szempontok miatt, viszont fix időközönként felébred. Mikor felébred lekéri a saját specifikus moduljától a jelenlegi mért állapotot, majd azt megpróbálja közvetíteni a központba. Ezt addig próbálja, amíg nem sikerül, vagyis a központ vissza nem küld egy automatikus jelzést, hogy megérkezett az adat. Szenzorok közé sorolhatók például a sok féle mérőeszközök vagy akár egy mozgásérzékelő is.</p>
<h3 id="aktorok"><span class="header-section-number">2.1.2</span> Aktorok</h3>
<p>Az aktorok a rendszer olyan részei, amik segítségével a rendszer képes változtatásokat végbe vinni a fizikai világban. Hasonló a helyzet a szenzorok esetéhez, hiszen ugyanúgy a mikrokontroller kezel mindent. Ugyanúgy alvó állapotban van az eszköz az idő nagy részében, viszont jelen esetben nem fix időközönként ébred fel, hanem amikor üzenetet kap a központtól. Ezek az üzenetek állapot beállítási parancsok, vagyis utasítják az eszközt, hogy állítson át vagy cselekedjen valamit. Ha megtörtént a parancs feldolgozása, az eszköz egyből elküldi a központi rendszernek az új állapotát, állapotjelentés formájában, akárcsak a szenzorok, majd megint alvó állapotba kerül a következő parancsig. Aktor lehet például egy elektromos relé vagy egy termosztát is.</p>
<p>Tehát láthatjuk, hogy miért is nem szétválasztható a két csoport. Az aktorokra tekinthetünk olyan szenzorokként, amik képesek még egyéb funkcionalitást is végezni. Így tekintve a szenzorok csoportja tágabb és magába foglalja az aktorok csoportját.</p>
<h2 id="hálózati-réteg"><span class="header-section-number">2.2</span> Hálózati réteg</h2>
<p>A hálózati réteg léte elsőnek nem látszik logikusnak. Feleslegesnek tűnhet egy plusz szereplőt bevonni a központi szerver és az eszközök közé. A probléma, ami mégis megköveteli azt, hogy legyen egy köztes réteg, az egy eszközökhöz kötődő döntésből fakad.</p>
<p>A hardveres tervezés alatt találkoztam több vezetéknélküli kommunikációs modullal is. Volt olyan, ami WiFi-t használ a kommunikációhoz, volt, ami csak simán rádiófrekvenciás modul volt. Bizonyos okok miatt, amit majd a . alfejezetben fogok leírni, a rádiófrekvenciás modulok mellett döntöttem. Így viszont szükség van egy központi eszközre, ami egy ugyanolyan kommunikációs modullal kell rendelkezzen, mint a többi eszköz. Ahhoz, hogy ezt a modult használni tudjuk, viszont alacsonyabb szintű eszközökhöz kell folyamodni, mint amit a Java nyújtani tud. Pont ezért a hálózati réteg egésze C++-ban íródott.</p>
<p>Lényegében a hálózati réteg tartja fent a kapcsolatot az eszközökkel és alakítja át az üzeneteket a fogadó félnek megfelelő formátumra. Ez az alakítás azért szükséges, mert a kommunikáció a hálózati réteg és a központi szerver között egy TCP kapcsolaton keresztül történik JSON objektumok küldésével, viszont a hálózati réteg és az eszközök között C-beli <code>struct</code>-okat küldünk rádiófrekvenciás jelek segítségével.</p>
<h2 id="központi-szerver"><span class="header-section-number">2.3</span> Központi szerver</h2>
<p> A legnagyobb funkcionalitást természetesen a központi szerver végzi, hiszen ott lesznek feldolgozva az eszközöktől érkező állapotjelentések és a szerver küldhet állapot beállítási parancsokat is.</p>
<p>Mint említve volt már a központi szerver TCP kapcsolaton keresztül kommunikál a hálózati réteggel. Az onnan érkező üzeneteket a rendszer például a megfelelő formában elmenti az adatbázisban vagy az üzenet hatására elindulhatnak bizonyos döntéshozási folyamatok is.</p>
<p> A központi szervert is tovább tudjuk bontani több darabra funkcionalitása alapján:</p>
<ul>
<li>Flow-rendszer</li>
<li>Statisztika</li>
<li>Kezelőpanel</li>
</ul>
<h3 id="flow-rendszer"><span class="header-section-number">2.3.1</span> Flow-rendszer</h3>
<p>A <em>Flow-rendszer</em> onnan kapta a nevét, hogy a felhasználó által megadható szabályokat &quot;flow&quot;-knak neveztem el. A név a beérkező adatok folyamából és azoknak folyamatos feldolgozásából jön. Minden flownak van feltétele és hatása. Ez a hatás akkor fog bekövetkezni, ha a feltétel teljesül. Részletesebben a . alfejezetben lesz szó a flowkról.</p>
<p>A <em>Flow-rendszer</em> biztosítja az új szabályok létrehozásának, régebbiek módosításának lehetőségét és elmenti az így létrejött változásokat. Másik lényeges feladata ennek a rendszernek még, hogy be is tartassa ezeket a szabályokat. A szabályok betartásáért felelős mechanizmust szintén a . alfejezetben fogom taglalni. Röviden összefoglalva, ha új adat érkezik, a rendszer megnézi melyik szabályokat érintheti az esemény és kiértékeli azokat. Tulajdonképpen ez a rendszer felelős a szerver legfontosabb és legbonyolultabb funkcióiért.</p>
<h3 id="statisztika"><span class="header-section-number">2.3.2</span> Statisztika</h3>
<p>A rendszer használata során természetesen szeretnék néha visszanézni régebbi méréseket. Lehet ennek sok oka, például szeretnénk megnézni mennyivel volt hidegebb az előző hónapban, vagy leellenőrizhetjük mennyit volt bekapcsolva a fűtés. Tehát elég könnyen adja magát az elvárás, hogy tudjunk statisztikákat nézni a múltbeli adatokról.</p>
<p>Ehhez viszont el kell tárolni minden adatot, hogy később is tudjunk valamit mutatni a felhasználónak. Az adatbázis-rendszer kiválasztásánál ez volt az egyik legnagyobb szempont. A választás a <em>MongoDB</em>-re jutott, viszont a döntés mögött álló érveket majd a . alfejezetben fogom ismertetni. Mindemellett ahhoz, hogy az a sok adat, amit elmentenénk ne foglaljon sok tárhelyet, nem külön mentődnek el, ahogy beérkeznek a szerverhez, hanem percenként átlagolva kerül az adatbázisba. Ezzel igaz, hogy egy kicsi pontosságot vesztünk mikor visszanézzük a statisztikákat, viszont, ha jobban belegondolunk nincs is szükségünk arra, hogy például 10 másodpercenkénti részekre lebontva lássuk a múlt heti hőmérsékletet. Ami azt illeti még a percenkénti lebontás is túl aprónak tűnik bizonyos helyzetekben, de természetesen a lementett adatok segítségével elő tudunk állítani akár napi vagy havi átlagokat is. Mindezt grafikonokon és idősor diagrammokon mutatva, a felhasználó könnyedén tud következtetések levonni magának.</p>
<h3 id="kezelőpanel"><span class="header-section-number">2.3.3</span> Kezelőpanel</h3>
<p>A kezelőpanel szolgáltatja a felhasználó számára a valós idejű adatokat. Itt jelennek meg a beérkező állapotjelentések az eszközöktől legelőször, illetve aktorok esetében itt lesz lehetőségünk kézzel átállítani az eszköz állapotát, vagyis állapot beállító parancsokat küldeni.</p>
<p>Lehetővé válik így, hogy a felhasználó akár a munkahelyéről is megnézhesse, hogy áll az otthona, esetleg nem hagyta-e nyitva az ajtót reggel. Ez a pár másopercenként frissülő kezelő felület minden eszköztípushoz külön mini megjelenítő modulokat rendel, aminek köszönhetően akár pár pillanat alatt megtalálhatjuk a számunkra fontos információkat.</p>
<h1 id="eszközök-1"><span class="header-section-number">3</span> Eszközök</h1>
<p>Az előző fejezetben megtudtuk, mit csinálnak az eszközeink. Szintén megismertük, hogy mit is jelent a <em>szenzor</em> és az <em>aktor</em> fogalma, illetve, hogy miben különböznek. Ebben a fejezetben ecsetelve lesz, milyen hardverek lettek kiválasztva az eszközök összeállítására, illetve meg lesznek indokolva ezen választások is.</p>
<p>Ugye tudjuk szintén az előző fejezetből, hogy minden eszköz &quot;agya&quot; egy mikrokontroller. Ez a kicsi és alacsony teljesítményű processzor felelős az adatgyűjtés folyamatának koordinálásáért. Az <em>Arduino</em> fejlesztői platformok mellett tettem le a voksom, mert nem igényel elmélyült hardverismeretet a programozásuk.</p>
<p>Másik fontos alkotóelem, a vezetéknélküli modul. Ebben a választásban már természetesen megszorítás volt, hogy a kiválasztott modul kompatibilis legyen Arduinokkal. Habár nem volt egyszerű döntés, egy <em>nRF24L01+</em> adó-vevő integrált áramkört felhasználó modult választottam.</p>
<p>Ahogy korábban említettem harmadik része az eszközeinknek változó, még pedig az határozza meg, hogy mit szeretnénk elérni az adott szenzorral vagy aktorral. A fejlesztés elején kiválasztottam pár eszköztípust, amit el szerettem volna készíteni és támogatni a kész rendszerben. A teljesség igénye nélkül be fogok mutatni pár szenzor és aktor modult, mint például a hőmérséklet mérésére szolgáló <em>DHT22</em> hő- és légnedvesség mérő szenzor modult.</p>
<p>Mindezek után kitérek arra, hogy a fent említett hardvereket hogyan kell összekötni, hogy egy működő eszközt kaphassunk. Szerencsémre az összerakási folyamat nem igényelt jelentős villamosmérnöki tudást, elég volt néhány kábellel összekötni a megfelelő ki- és bemeneteket.</p>
<h2 id="hardver-választás"><span class="header-section-number">3.1</span> Hardver választás</h2>
<h3 id="arduino"><span class="header-section-number">3.1.1</span> Arduino</h3>
<p>Az <em>Arduino-k</em> egyszerűen használható <em>AVR</em> mikrokontroller alapú fejlesztői platformok, melyeknek az a céljuk, hogy megkönnyítsék az elektronikával való ismerkedést az átlagemberek számára. Ezeket az eszközöket az <em>Arduino</em>, mint vállalat tervezte, illetve tervezi, hiszen folyamatosan újabb és újabb <em>Arduino</em> platformok kerülnek napvilágra. Az <em>Arduino</em> vállalatnak fő célja az volt az <em>Arduino</em> eszközök tervezésénél, hogy minél több embernek legyen elérhető az elektronikus eszközökkel való barkácsolás. Mindezt úgy próbálják elérni, hogy olcsón előállíthatóak az eszközök, hogy leegyszerűsítették a programozást, illetve, hogy minden hardver tervet nyílt forrásúvá tettek. <span class="citation">[ARD 1]</span></p>
<p>Az én választásom is a fent említett előnyök miatt esett az <em>Arduino</em> fejlesztői platformokra. A nyílt források miatt kínai <em>Arduino</em> klónok lepték el a piacot. Akár 1000 forintért<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> is hozzájuthatunk egy ilyen klónhoz, de akár az eredetit is beszerezhetjük szintén nem túl drágán körülbelül 6000 forintért<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> magyarországi internetes boltokból.</p>
<p>A legfontosabb érv számomra mégis az, hogy nagyon egyszerű programozni az <em>Arduinokat</em>. Ezért is figyeltem fel rájuk és töltöm sokszor szabadidőmet <em>Arduinokat</em> használó saját projektekkel. A platformok mellé az <em>Arduino</em> vállalat aktívan fejleszt egy saját programozási környezetet és egy programozási nyelvet is. Az <em>&quot;Arduino&quot;</em> programozási nyelv valójában egy olyan C/C++ könyvtár, amely egyszerűsíti az eszközök használatóhoz kapcsolódó programozási feladatokat. Például ahhoz, hogy egy LED-et villogtassunk elég a következő kód: </p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="co">// the setup function runs once when you press reset or power the board</span>
<span class="dt">void</span> setup() {
  <span class="co">// initialize digital pin LED_BUILTIN as an output.</span>
  pinMode(LED_BUILTIN, OUTPUT);
}

<span class="co">// the loop function runs over and over again forever</span>
<span class="dt">void</span> loop() {
  <span class="co">// turn the LED on (HIGH is the voltage level)</span>
  digitalWrite(LED_BUILTIN, HIGH);
  <span class="co">// wait for a second</span>
  delay(<span class="dv">1000</span>);                       
  <span class="co">// turn the LED off by making the voltage LOW</span>
  digitalWrite(LED_BUILTIN, LOW);
  <span class="co">// wait for a second</span>
  delay(<span class="dv">1000</span>);                       
}</code></pre></td></tr></table></div>

<p>Továbbá mivel C/C++ az alapnyelv az <em>Arduino</em> &quot;nyelv&quot; támogat minden olyan C vagy C++-beli nyelvi elemet, amit az <code>avr-g++</code> fordítóprogram támogat. <span class="citation">[ARD 2; ARD 3]</span></p>
<h3 id="vezetéknélküli-modulok"><span class="header-section-number">3.1.2</span> Vezetéknélküli modulok</h3>
<p> A vezeték nélküli modulok közti jó választás fontos pontja a rendszernek és nagy hatással van később a működés menetére vagy stabilitására. Négy nagyobb szempont szerint vizsgáltam a jelölteket: ár, áramfogyasztás, hatótáv, sebesség. Ugye a célunk az, hogy minél olcsóbban érjünk el nagy hatótávokat. A sebesség szerencsére nem fontos számunkra, hiszen alkalmanként küldünk csak egy pár bájtnyi üzenetet. Annál inkább lényegesebb az áramfogyasztás, mert természetesen ezek az eszközök elemekről működnek majd. Ezért korlátozó tényező az áramforrás kapacitása és a teljesítménye is, vagyis, hogy mekkora áramerősségre képes. Háromféle modult vettem számításba és hasonlítottam őket össze egymással a végleges döntés meghozásához.</p>
Elsőként az <em>nRF24L01+</em> alapú modulokat mutatom be. Az <em>nRF24L01+</em> modulok olcsónak tekinthetőek, hiszen akár 500 forint körül megvásárolhatunk egyből 2 darabot.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> A modul nem csak olcsó, hanem az áramfogyasztása is kiváló. Mind a üzenet fogadás és küldés közbeni nagyjából 12 milliamperes fogyasztás kivételesen jó. Összehasonlításnak, ha önmagában az <em>nRF24L01+</em> modult kellene működtetni egy gombelemről, akkor 10-15 órás folyamatos üzenet küldésre vagy fogadásra lennénk képesek és ha ezt úgy nézzük, hogy egyszerre csak a másodperc töredékéig kell aktívan küldeni vagy fogadni nagy időközönként, akkor láthatjuk tényleg mennyire is kevés az <em>nRF24L01+</em> modul fogyasztása. <span class="citation">[NRF 1]</span> Sebességet tekintve közép kategóriába sorolható, ugyanis a modul képes a maximum 2 Mb/s adatátviteli sebességre. A 2 Mb/s nem mondható túl nagynak, de ugye sebességre nincs is nagy szükségünk. Ha viszont lentebb vesszük a sebességét a moduloknak 250 kb/s-ra, akkor még hatótávban is nyerhetünk pár métert. Minden közül a legfontosabb tulajdonsága egy vezeték nélküli modulnak az, hogy mennyire messze ér el az adatátvitel. Ezen szempontból sincs szégyenkezni valója az <em>nRF24L01+</em> moduloknak. Természetesen a hatótávra rendkívül nagy hatással vannak a környezeti tényezők, például mennyi akadály van az adó és vevőt között. Mivel az <em>nRF24L01+</em> 2.4 GHz-es vivőfrekvenciával működik a modulok a beltéri hatótáv többszörösét tudják elérni egy szabadtéren. De szintén hátráltató tényező a WiFi hálózatok jelenléte, hiszen azok is a 2.4 GHz-es frekvenciákon működnek. Mindezek ellenére a modul képes akár 100 méteren keresztül is az adatátvitelre és ha azt tekintjük, hogy a rendszer célja, hogy egy háztartásban működjön, akkor még a 25 méteres hatótáv is elég lehet számunkra. <span class="citation">[NRF 2; NRF 3]</span>

A második modul az <em>ESP8266</em>, ami egy WiFi-n keresztül kommunikáló eszköz. Azzal, hogy WiFi-képes a modul az is lehetséges, hogy közvetlen az internetre csatlakozva küldjünk üzeneteket és ezáltal nem is feltétlen lenne szükség egy közvetítőre a szenzorok, az aktorok és a központi rendszer között. Ezzel a tulajdonsággal, viszont olyan hátrányok járnak, mint aránylag rövid hatótáv és rendkívül nagy áramfogyasztás. Maga az <em>ESP8266</em> is képes WiFi hozzáférési pontként funkcionálni és jó hatótávokat elérni (akár 100 méternél is többet <span class="citation">[ESP 1]</span>), viszont mi úgy szeretnénk használni, mint egy routerhez kapcsolódó eszközt, ezért a router hatótávja korlátoz minket. Egy router hatótávja viszont általában tekintve nem a legfényesebb, van, hogy alig ér be egy-egy háztartást. Áramfogyasztást tekintve üzenetküldés alatt 100 milliamper körül fogyaszt, olykori 300-350 milliamperes csúcsokkal. Ezen csúcsok miatt elég nagy teljesítményű áramforrásokra lesz szükség a működtetéséhez, amik maguk is sok áramot fogyasztanak. Ráadásul a modul fogyasztása is nagyon magas, nem is nagyon lehetséges sokáig üzemeltetni, ha véges kapacitásokkal rendelkezünk. Az árat tekintve viszont jól áll az <em>ESP8266</em>, mert 2000 forintért<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> már hozzájuthatunk. <span class="citation">[ESP 2; ESP 3]</span>

Hátramaradtak a <em>Zigbee</em> modulok. Sok féle Zigbee létezik, de én a Series 1, 1 mW-os eszközöket vettem figyelembe, mert a nagyobb fogyasztású társai az <em>ESP8266</em>-höz hasonlóan túl hamar lemerítené az áramforrásainkat. Hiába van jó hatótávja, mint az <em>nRF24L01+</em> moduloknak, még a legenergiatakarékosabb variáció is többet fogyaszt nála. Hivatalosan a <em>Zigbee</em> eszközök 50 milliampert fogyasztanak, ami 3-szor vagy 4-szer több, mint az <em>nRF24L01+</em> fogyasztása. A sebessége a moduloknak elfogadható számunkra, 250 kb/s-ra képesek, ami elég, ahogy arra már korábban kitértem. <span class="citation">[ZIG]</span> Utoljára hagytam a legnagyobb hátrányát a modulnak, ami nem más, mint az ára. Darabja a <em>Zigbee</em> eszközöknek 8000 forint<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> körül van, ami túlságosan megemeli egy-egy szenzor előállítási költségét. Egy <em>Zigbee</em> árából akár 30 <em>nRF24L01+</em> modult is vehetünk, ami elég abszurdul hangzik.

<table>
<caption>Vezeték nélküli modulok összehasonlítása </caption>
<thead>
<tr class="header">
<th align="left">Modulok</th>
<th align="left">nRF24L01+</th>
<th align="left">ESP8266</th>
<th align="left">Zigbee</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Sebesség</td>
<td align="left">250 kb/s-2 Mb/s</td>
<td align="left">1-5 Mb/s</td>
<td align="left">250 kb/s</td>
</tr>
<tr class="even">
<td align="left">Fogyasztás</td>
<td align="left">~ 12 mA</td>
<td align="left">~ 100 mA</td>
<td align="left">50 mA</td>
</tr>
<tr class="odd">
<td align="left">Hatótáv</td>
<td align="left">30-100 m</td>
<td align="left">10-30 m</td>
<td align="left">30-100 m</td>
</tr>
<tr class="even">
<td align="left">Ár</td>
<td align="left">~ 250 Ft/db</td>
<td align="left">~ 2000 Ft/db</td>
<td align="left">~ 8000 Ft/db</td>
</tr>
</tbody>
</table>
<p>A fejezet elején már említettem, hogy az <em>nRF24L01+</em> modulokat választottam, amiben főleg az ára és az áramfogyasztása játszott nagy szerepet. Mind a három eszköz megfelelt a sebesség és hatótáv feltételeimnek, így könnyen látható a . táblázatból, hogy a maradék két szempontot nézve egyértelműen az <em>nRF24L01+</em> eszközök a nyerőek.</p>
<h3 id="eszköz-specifikus-hardver"><span class="header-section-number">3.1.3</span> Eszköz specifikus hardver</h3>
<p>Közös megszorítás volt természetesen minden eszköz specifikus modul kiválasztásánál, hogy könnyedén lehessen használni <em>Arduinokkal</em>. Ez általában abban nyilvánult meg, hogy az interneten találtam-e <em>Arduinokhoz</em> írt könyvtárakat, amik az adott modul képességeinek használatát teszik lehetővé. Választási szempontom volt még, hogy mennyire drága az eszköz. Néhol érdemes feláldozni a mérési pontosságot ahhoz, hogy ne kelljen sok pénzt kiadni. Mivel minden eszköztípus más érzékelőt vagy más funkciót elvégző alkatrészt tartalmaz, illetve mivel konkrétan akármilyen funkciójú eszközt megtervezhetünk, ezért nem tudok minden eszköz specifikus modult bemutatni. Viszont korábban említettem, hogy kiválasztottam pár szenzort és aktort, amit megterveztem és támogattam a rendszer fejlesztése során. Ezek a következőek:</p>
<ul>
<li>Hő- és páratartalom szenzor</li>
<li>Mozgásérzékelő szenzor</li>
<li>Föld nedvesség szenzor</li>
<li>Elektromos relé aktor</li>
</ul>
A <em>hő- és páratartalom szenzor</em> elkészítéséhez az úgynevezett <code>DHT22</code> modult használtam, ami egyszerre képes hőmérsékletet és páratartalmat mérni. Eredetileg nem terveztem, hogy egy szenzor akár többféle adatot is tud szolgáltatni a központi rendszernek, de mivel egy ilyen kettő-az-egyben modult találtam, ezért hamar változtattam az eredeti elképzeléseimen. Azért ezt a DHT22 modult választottam, mert szinte csak ehhez találtam <em>Arduinot</em> használó példákat. Pontosságát tekintve a 2%-os páratartalom és 0.5°C-os hőmérséklet hibahatár bőven megfelelt az én céljaimra. <span class="citation">[DHT]</span> A modul ára is aránylag kedvező, hiszen körülbelül 3000 forintért<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> beszerezhető egy-egy darab.

A <em>mozgásérzékelő szenzor</em> elkészítéséhez <code>PIR szenzort</code> használtam. A PIR feloldása a &quot;<em>passive infrared</em>&quot;, vagyis az infravörös fények változását képes érzékelni a szenzor. Ilyen PIR szenzorokat használnak például a mozgásra felkapcsoló kertilámpák is. Ezek egyszerű eszközök, általában működésük annyiból áll, hogy amikor mozgást érzékelnek elindul egy időzítő és az amíg le nem jár, addig a modul magas jelet ad. Ahogy az időzítő lejárt eltűnik a jel. Ennek a jelnek az értelmezése rendkívül egyszerű <em>Arduinokkal</em>. Elég, ha rákötjük a PIR szenzor kimenetét az <em>Arduino</em> egyik bemenetére és figyeljük mikor változik a bemeneten a jel. Az időzítő hossza és a modul érzékenysége kézzel állítható az eszközön. Ahogy az előző esetben is, most se magas az ára egy ilyen modulnak. Körülbelül ezek a szenzor modulok is 3000 forintba<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> kerülnek.

A <em>föld nedvesség szenzor</em> még a <em>mozgásérzékelő szenzornál</em> is egyszerűbb mérőeszközt igényel. A legegyszerűbb módja annak, hogy a föld nedvességét megmérjük az, hogy két föld alá dugott fémlemez között megmérjük a föld ellenállását. Minél kisebb az ellenállás, annál nedvesebb a föld. Ezt az elvet használó érzékelő modulokat könnyedén lehet találni és nem is drágán. Egy-egy ilyen érzékelő ára 1500 forint<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> körül mozog. Ahhoz, hogy működésre bírjuk ezeket az eszközöket, szintén csak annyi a dolgunk a kimenetet az <em>Arduino</em> egyik bemenetére kötjük és onnan leolvassuk az ellenállás értékét. Abból tudunk következtetni mennyire száraz vagy nedves a föld.

Az <em>elektromos relé aktor</em> esetében egy 5 voltos relére volt szükségem. Ha magasabb feszültséget igénylő relét akartam volna használni, akkor plusz alkatrészekre lett volna szükségem ahhoz, hogy <em>Arduinoval</em> irányíthassam. Egy relé alapvetően úgy működik, mint egy akármilyen villanykapcsoló, a különbség csak annyi, hogy elektromos jellel lehet kapcsolni. A relé egyik oldalára az irányítani kívánt áramkört kell bekötni, a másikra a mi esetünkben az <em>Arduino</em> egy kimenetét és az említett 5 voltot. Így a kimenet fel- és lekapcsolásával a bekötött áramkört is kapcsolgatjuk. Az ára a reléknek rendkívül változó tud lenni, annak függvényében, hogy mekkora teljesítményt bírnak ki. Én egy 10 ampert kibíró relé mellett döntöttem, ami 2500 forint<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a> körüli összegbe kerül.

<h2 id="felépítés"><span class="header-section-number">3.2</span> Felépítés</h2>
<p>Így, hogy minden alkatrészt kiválasztottunk a következő feladat, hogy össze is rakjuk az eszközeinket. Az első és legfontosabb lépés, hogy áramot kapjon a fő alkatrészünk, az <em>Arduino</em>. Magán az <em>Arduinon</em> elhelyezett feszültség szabályzónak köszönhetően, képesek vagyunk akár egy 9V-os elemmel is megoldani az áramellátást. A példa kedvéért most maradjunk ennél a megoldásnál annak okán, hogy ne kelljen fölösleges feszültség átalakításokkal foglalkozni. Valójában úgy terveztem viszont az eszközt, hogy egy tölthető, 3.7V-os lithiumion-akkumulátor üzemeltesse a szenzorjainkat, aktorjainkat.</p>
<p>Ha megoldottuk az áramellátás kérdését, jöhet a kommunikáció felállítása a központi szerverrel. Ehhez az úgynevezett <em>SPI</em> (&quot;<em>Serial Peripheral Interface</em>&quot;) buszt kell használjuk az <em>Arduino</em> és az <em>nRF24L01+</em> közötti kommunikációhoz. Sajnos magam sem ismerem mélyrehatóan az <em>SPI</em> technológiát, hiszen programtervező informatikusnak tanulok, viszont röviden összefoglalva az <em>SPI</em> egy soros kommunikációs interfész, amely <em>master-slave</em> architektúrára épül. Tehát van egy <em>master</em> eszköz és elviekben tetszőleges számú <em>slave</em>, ahol a <em>master</em> eszköz irányítja teljes egészében a kommunikációt és a <em>slave</em> eszközök csak a <em>master</em> jelére kezdenek el adatot küldeni. Összesen négy kábel elég ahhoz, hogy a kapcsolat létrejöjjön az <em>Arduino</em> és az <em>nRF24L01+</em> között. Ahogy összekötöttük őket a full-duplex kapcsolaton keresztül máris tudunk adatot küldeni más <em>nRF24L01+-t</em> használó eszközöknek. <span class="citation">[SPI]</span></p>
<p>Hátra van még az eszköz specifikus rész bekötése. Természetesen ez eszközről eszköre változik, viszont mivel szükség lesz az <em>Arduino</em> megszakítás rendszerére, az egyetlen megszorítás, hogy olyan bemenetre kell bekötni a specifikus eszközt, ahol az <em>Arduino</em> támogatja a megszakításokat. A megszakításokat később, a . alfejezetben fogom ismertetni.</p>
<h3 id="példák-kész-eszközökre"><span class="header-section-number">3.2.1</span> Példák kész eszközökre</h3>
<p>Csak felsorolásszerűen bemutatnám képekben annak a pár eszköznek a felépítését, amelyeket korábban említettem, mint a rendszer által támogatottak. A képek nem feltétlen fedik le a valós, összerakott eszközök felépítését. Ennek oka annyi, hogy másképp nem feltétlen lennének jól értelmezhetőek az ábrák. Például bizonyos esetekben az <em>nRF24L01+</em> kommunikációs modul nem megfelelő tápfeszültséget kap a képeken, viszont ez nem változtat semmit a valódi bekötési ábra számunkra is lényeges részeihez képest.</p>
<ul>
<li>Hő- és páratartalommérő szenzor
</li>
<li>Mozgásérzékelő szenzor
</li>
<li>Elektromos relé aktor
</li>
</ul>
<h2 id="firmware-működés"><span class="header-section-number">3.3</span> Firmware működés</h2>
<h3 id="megszakítások"><span class="header-section-number">3.3.1</span> Megszakítások</h3>
<p> A fejlesztés közben szembesültem azzal, hogy különbséget kell tegyek szenzorok közt is a kívánt működésüket tekintve. Pontosabban fogalmazva abban különbözhet egyik szenzor a másiktól, hogy mikor kell adatot küldjön a központi szervernek. Gondoljunk bele abba, hogy egy hőmérő szenzor elég, ha fix időközönként elküldi az aktuális állapotát. Ha viszont tegyük fel egy mozgásérzékelő szenzorról beszélünk, akkor azt szeretnénk, hogy ha mozgás van a szobában, akkor egyből elküldje az új adatot a szenzor. Ugyan ez az helyzet például egy ajtózárt irányító aktor esetében is. Azonnal szeretnék értesülni arról, hogy kinyitották a bejárati ajtót, nem pedig akkor, ha éppen úgy esik a fix időközönkénti állapot küldés. A fix időközönként közvetítő szenzort időzített szenzoroknak neveztem el, míg azokat, amik állapotváltozást igényelnek, hogy elküldjék az adatot, reaktív szenzoroknak.</p>
<p>Az eszközök felépítésének bemutatásánál említettem a megszakítások fogalmát és azt, hogy szükségünk lesz rájuk. A megszakítások olyan külső vagy belső jelek, amelyek a feldolgozó egység számára szólnak, hogy azonnali figyelmet igényel valamilyen hardver vagy szoftver. Az <em>Arduinok</em> esetében egy ilyen megszakítás lehet egy bemeneti jel változás vagy esetleg egy belső időzítő lejárta. Másik fontos tulajdonsága a megszakításoknak az <em>Arduinoknál</em>, hogy egy megszakítás hatására az eszköz képes felébredni alvó állapotból. <span class="citation">[INT 1; INT 2]</span> Így viszont meg is oldottuk a szenzorok közti különbség problémáját, hiszen, ha az <em>Arduino</em> normál állapotban van, akkor leolvassuk az aktuális állapotát az eszköznek, elküldjük a központi szerverhez az adatot, majd alvó módba lépünk. Ahhoz, hogy az időzett szenzorok fix időközönként közvetítsenek a belső időzítőt kell használni az eszköz felébresztésére, a reaktív szenzorok esetében egy olyan bemenetre kell kötni az érzékelő modult, ahol az <em>Arduino</em> támogatja a megszakításokat. Így elértük azt, hogy ha például valamilyen mozgást érzékelünk az eszköz egyből felébred és elküldi az új állapotot.</p>
<p>Az aktorok esete szintén eltér az eddigiektől, mivel az aktorok nem csak üzennek a központi szervernek, hanem fogadnak is onnan érkező parancsokat, az eszköznek normál állapotában kell működnie ahhoz, hogy a parancsot fel tudja dolgozni. Ennek ellenére szeretnénk, ha az aktorok is tudnának alvó állapotban lenni energiatakarékosság miatt. Szerencsére az <em>nRF24L01+</em> képes nekünk megszakításokat generálni, ha valamilyen üzenet érkezett az eszköz számára. Ez pont tökéletes számunkra, hiszen csak akkor fogjuk így felkelteni az <em>Arduinot</em> alvó állapotból, ha fel kell dolgozni a központól érkezett parancsot.</p>
<h3 id="alacsony-fogyasztás"><span class="header-section-number">3.3.2</span> Alacsony fogyasztás</h3>
<p>Mindegyik eszköznek, működése folyamán, van olyan időköze, amikor nem kell semmilyen feladatot elvégezzen. Szenzoroknál például két állapot leolvasás közt vagy aktorok esetén két parancs feldolgozás közt. Felmerül a kérdés, hogy amíg nincs szükségünk az eszközök teljes számítási kapacitására, addig tudnánk-e valamilyen módon energiát megtakarítani annak érdekében, hogy kevesebbszer kelljen elemet cserélni bennük. Korábban már említettem, hogy az <em>Arduinok</em> képesek <em>alvó módba</em> lépni és ezzel elérjük azt, hogy spóroljon az energiával. Ha például a legalacsonyabb energiafelhasználású módba tesszük az eszközt akár 40-szer kevesebb áramot fogyaszthat az <em>Arduinon</em> elhelyezett <em>AVR</em> mikrokontroller. Ez viszont jelentős üzemidő javulást jelenthet, így akár pár napnyi működés helyett hónapok is lehetnek. Lehetőségünk van még arra is, hogy kikapcsoljuk az AVR mikrokontroller nem használt részeit. Kikapcsolhatjuk például az analóg-digitális átalakítót vagy bizonyos belső időzítőket. Alkalmazhatjuk például úgy ezt a módszert, hogy mielőtt alvó módba lép az eszköz kikapcsoljuk minden részét a mikrokontrollernek és majd csak akkor visszakapcsoljuk azokat, ha felébred. Illetve azokat a részeket véglegesen kikapcsolhatjuk, amik olyan funkciókért felelnek, amiket sose használunk.</p>
<p>Tovább tudjuk faragni a fogyasztást bizonyos hardveres módosításokkal. Minden <em>Arduinon</em> található egy LED, ami folyamatosan ég amíg az eszköz áramot kap. Ha ezt a LED-et eltávolítjuk szintén jelentős mennyiségű energiát megspórolhatunk és igazából szükségünk sincs arra a jelző fényre. Található még az <em>Arduinokon</em> egy feszültség szabályzó integrált áramkör, ami általában nem a legjobb hatékonysággal rendelkezik. Természetesen ennek az az oka, hogy ahol csak lehet az olcsóbb alkatrészeket választják a gyártási költségek minimalizálása miatt. A feszültség szabályzó cseréje egy hatékonyabbra szintén segíthet valamennyit. Akár a teljes eltávolítása is megoldás lehet még, csak sajnos a mi esetünkben szükség van rá, így ez nem járható út. <span class="citation">[ARD 4]</span></p>
<h1 id="hálózati-réteg-1"><span class="header-section-number">4</span> Hálózati réteg</h1>
<p>Az áttekintő fejezeteben említésre került, hogy miért van szükség a hálózati rétegre. Ez a mondhatni közvetítő réteg annak ellenére, hogy nem végez el sok funkcionalitást, mégis sok munkát igényelt a fejlesztés során. A nehézség nem feltétlen csak a szoftver előállításából adódott, hanem a megfelelő hardverek megtalálásából és azok összehangolásából. Ahhoz, hogy fogadni tudjuk az eszközök üzeneteit ugyanolyan <em>nRF24L01+</em> adó-vevő modult kell használni a hálózati rétegben is, mint az eszközökben. Mivel az ahhoz való kapcsolódás és kommunikáció alacsony szintű hardverhozzáférést igényel és SPI buszt egy hétköznapi számítógép nem megfelelő számunkra. Léteznek viszont úgynevezett <em>single-board</em> számítógépek, amelyek pont az ilyen esetekre lettek kitalálva. Egy-egy ilyen számítógépen található egy aránylag nagy teljesítményű processzor, pár megszokott ki- és bemenet perifériák számára (pl.: USB portok) és ami a legfontosabb számunkra GPIO pinek vagy másnéven <em>általános-célú ki- és bemenetek</em>. A GPIO-n keresztül lesz lehetőségünk az adó-vevő modullal kommunikálni. Az én választásom a <em>Raspberry Pi 3</em> apró számítógépre esett.</p>
<p>Szó lesz még a fentiek mellett a hálózat felépítéséről, hogy miként is kapcsolódnak és kapnak címet az eszközök. Habár mindezt az <em>nRF24L01+</em> modulhoz fejlesztett külső programkönyvtár végzi, mégis jelentős részét képezi a hálózati réteg működésének. A hálózat maga <em>mesh alapú</em>, viszont ez csak a programkönyvtárnak köszönhető, ezért nevezném inkább <em>pszeudo-mesh</em> hálózatnak, amit meg is fogok magyarázni miért. Ha már tudjuk, hogyan kapcsolódunk a hálózathoz, akkor már csak az üzenetek küldése hiányzik. Ismertetni fogom, hogy milyen felépítésűek az állapot jelentő vagy állapot beállító üzenetek a szerver és hálózati réteg között, illetve a hálózati réteg és az eszközök között.</p>
<p>Ezek után röviden bemutatom, hogy miként is épül fel a hálózati réteg szoftvere, hogy hol voltak gondjaim a fejlesztés során. Illetve említésre kerül még a C++ <em>Boost</em> könyvtárcsomag, mivel rendkívül megkönnyítette számomra a TCP kapcsolat kezelését a központi szerverrel.</p>
<h2 id="mesh-hálózat"><span class="header-section-number">4.1</span> Mesh hálózat</h2>
<p>Ahogy említettem a teljes eszköz hálózat irányítását egy külső programkönyvtár végzi. Elvégez olyan feladatokat, mint például az automatikus cím kiosztás vagy éppen az útkeresés két eszköz között az üzenetküldéshez. Ezeknek köszönhetően az eszközök automatikusan be tudnak csatlakozni a hálózatba, annak bármely pontján és el tudnak érni bármilyen eszközt, ami aktív része a hálózatnak. Ezáltal a végfelhasználónak nem kell konfigurációval foglalkoznia a hálózat miatt, hiszen minden eszköz miután bekapcsoltuk saját maga végzi el a szükséges feladatokat, ahhoz, hogy a hálózathoz csatlakozhasson. Ezt a programkönyvtárat a <em>TMRh20</em> névre hallgató <em>GitHub</em> felhasználó készítette el és az <em>RF24Mesh</em> nevet adta neki,<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a> amely az <em>nRF24L01+</em> adó-vevő modullal való munkát könnyíti meg.</p>
<h3 id="felépítés-1"><span class="header-section-number">4.1.1</span> Felépítés</h3>
<p> A <em>mesh</em> hálózatok legfontosabb tulajdonságai közé tartozik, hogy minden csomópontja a hálózatnak résztvesz az adatforgalom továbbításában, illetve, hogy a hálózat maga oldja meg az esetleges kapcsolati problémák okozta hálózati elérhetetlenséget. Mindez úgy valósulhat meg, hogy a csomópontok között akár több útvonal is létezik és ha egy csomópont elérhetetlenné válik, akkor újrakonfigurálja magát, hogy a hálózat másik pontján csatlakozhasson fel újra.</p>
<p>A felszínről nézve egy <em>mesh</em> hálózatot kapunk az <em>RF24Mesh</em> segítségével összekapcsolt eszközök csoportjából. Azonban a belső működés egy <em>fa-alapú</em> hálózatra épít és azt dinamikusan alakítva kapjuk meg a <em>mesh</em> hálózatot. Ezen működésnek nagy árulkodó jele például, hogy szükség van egy központi csomópontra, ahhoz, hogy a címkiosztás működjön. Ezen ok miatt neveztem <em>pszedo-mesh</em>-alapúnak a hálózatot a fejezet elején. Sajnos annak, hogy fa-alapra épül valójában a hálózatunk vannak következményei. A fa topológiából adódik, hogy minden eszközt csak egy úton tudunk elérni és ezért elveszítjük a redundáns utak előnyeit. Megvan az oka, viszont, hogy miért a fa topológia lett mégis felhasználva a belső működésre. Az <em>nRF24L01+</em> egyszerre összesen 6 kapcsolatot tud fenntartani, tehát, ha több út vezetne egy csomóponthoz, akkor hamar kifogyhatunk abból a 6 kapcsolatból. Ami azt illeti, még így is rendkívül hamar kevésnek tud bizonyulni. <span class="citation">[RF24 1]</span></p>
<p>Szerencsénkre nem minden eszköznek kell folyamatosan aktív része lenni a hálózatnak. Mivel az összes szenzor csak időszakosan kell rendelkezzen hálózati kapcsolattal, ezért mielőtt alvó módba lépnek lecsatlakozhatnak a hálózatról. Ezt csak azért léphetjük meg, mert a szenzorokat nem akarja elérni egy csomópont se. Ezzel ellentétben az aktoroknál nincs ilyen szerencsénk, hiszen az aktoroknak szólhatnak állapot beállító parancsok.</p>

<h3 id="címzés"><span class="header-section-number">4.1.2</span> Címzés</h3>
<p>Ahogy említettem a központi csomópont kezeli minden egyes hálózati eszköz címének kiosztását, a címek tárolását és a címek feloldását is. Minden eszköznek van egy egyedi, fix, 0-től 255-ig terjedő csomópont azonosítója. Tekinthetünk erre az azonosítóra, akárcsak egy MAC címre. Ezen azonosító segítségével tudunk majd üzeneteket címezni az adott csomópontnak. Amikor egy csomópont felcsatlakozik a hálózatra a központi csomópont kioszt neki egy hálózati címet, amelyet el is ment magának. A hálózati cím már viszont az IP címekhez hasonlítható. Közvetlen üzenetet küldeni csak a hálózati cím birtokában tudunk. Az automatikus cím kiosztás úgy működik, hogy az újonnan csatlakozott csomópont egy kérést indít a központ felé. A központ mindig a 0-ás csomópont azonosítóval rendelkezik, így az újonnan kapcsolódott csomópont is tudhatja hova kell küldeni a cím kérést. Ez nem csak a cím kérésnél érvényes természetesen, ha akármilyen üzenetet szeretnénk küldeni a központi csomópontnak akkor csak a 0-ás címnek kell címezni az üzenetet. Azonban, ha a címzett nem a központi csomópont, akkor szükséges egy kérést intézni a központi csomóponthoz, hogy lekérjük a csomópont azonosítóhoz tartozó hálózati címet, majd a megkapott hálózati címre elküldhetjük az üzenetet. <span class="citation">[RF24 1]</span></p>
<h2 id="üzenetek-felépítése"><span class="header-section-number">4.2</span> Üzenetek felépítése</h2>
<p>A hálózati réteg legfontosabb funkciója, hogy átalakítsa az üzeneteket megfelelő formátumra a központi szerver és az eszközök között. Erre azért van szükség, mert míg a központi szerverrel egy TCP kapcsolaton keresztül JSON üzenetekkel kommunikálunk, addig az eszközökkel nyers bitfolyamokon keresztül C-beli <code>struct</code>-okat használva tudunk. Egy üzenet típusa vagy állapot jelentés vagy állapot beállítás lehet.</p>
<p>Az üzenetekben használt csomópont azonosító megegyezik a . alfejezet csomópont azonosítóival. Az adat típus sztring literálok megmondják, hogy az adott eszköz milyen specifikus hardverrel rendelkezik, például a <code>temperature</code> adat típust a hőmérő szenzor használja. Fontos még megemlíteni, hogy logikusan az állapot jelentő üzenetek mindig egy eszköztől indulnak és az állapot beállító üzenetek mindig a központi szervertől.</p>
<h3 id="kommunikáció-a-központi-szerverrel"><span class="header-section-number">4.2.1</span> Kommunikáció a központi szerverrel</h3>
<p>Azért esett a választásom a TCP kapcsolaton keresztüli kommunikációra a központi szerver és a hálózati réteg közt, mert jelentősen egyszerűbb megoldani, mint más technológiákkal. Például megoldás lett volna még, hogy közös megosztott memória területen dolgozzon a központi szerver és a hálózati réteg. A hátránya az lett volna az osztott memóriának, hogy kötelező egy eszközön futnia a kapcsolat mindkét felének. Hasonló indokok állnak a mögött is, hogy miért JSON-t választottam az üzenetek formai alapjának. Szintén ez volt a legkönnyebben és leghamarabb megvalósítható megoldás. Habár itt már voltak más életképes megoldások is, mint például a Google által fejlesztett <em>Protobuf</em>, ami egy programozási nyelvfüggetlen adatcsere formátum. A JSON, azért tűnt mégis jobbnak számomra, mert könnyebben tudtam változtatni az üzenetek formátumán és kevesebb velejáró programozást igényelt.</p>
<ul>
<li><p>Állapot jelentés üzenet:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="dt">id</span><span class="op">:</span> [csomópont azonosító]<span class="op">,</span>
  <span class="dt">type</span><span class="op">:</span> [adat típusa]<span class="op">,</span>
  <span class="dt">value</span><span class="op">:</span> [adat érték]<span class="op">,</span>
  <span class="dt">category</span><span class="op">:</span> [aktor vagy szenzor]
<span class="op">}</span></code></pre></div></li>
<li><p>Állapot beállító üzenet:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="dt">id</span><span class="op">:</span> [csomópont azonosító]<span class="op">,</span>
  <span class="dt">targetState</span><span class="op">:</span> [kívánt állapot]
<span class="op">}</span></code></pre></div></li>
</ul>
<h3 id="kommunikáció-az-eszközökkel"><span class="header-section-number">4.2.2</span> Kommunikáció az eszközökkel</h3>
<p>Több különbség is észrevehető a központi szerver üzeneteihez képest. Elsőnek azt láthatjuk meg, hogy sehol nincs <code>id</code> mező, de nincs is rá szükség, mivel az üzenetet csak <code>id</code> csomópont azonosítóval rendelkező eszköznek küldjük el. Második különbség, hogy nincs <code>category</code> mező az állapot jelenő üzenetben. Erre azért nincs szükség, mert a hálózati kapcsolatot irányító programkönyvtár megengedi, hogy felcímkézzük az üzeneteket. Ezt kihasználva minden eszköz, mivel tudja magáról, hogy melyik kategóriába tartozik megfelelően címkézi az üzeneteket. Ez a címke lesz átalakítva mezővé a központi szervernek küldött üzenetekben.</p>
<ul>
<li><p>Állapot jelentés üzenet:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> state_update_message {
  <span class="dt">float</span> data; <span class="co">// adat érték</span>
  <span class="dt">char</span> type[<span class="dv">15</span>]; <span class="co">// adat típus</span>
};</code></pre></div></li>
<li><p>Állapot beállító üzenet:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> state_set_message {
  <span class="dt">float</span> targetState; <span class="co">// kívánt állapot</span>
};</code></pre></div></li>
</ul>
<h2 id="raspberry-pi"><span class="header-section-number">4.3</span> Raspberry Pi</h2>
<p>A <em>Raspberry Pi</em> eszközcsalád rendkívül nagy hírnevet szerzett a <em>single-board</em> számítógépek világában. Mára, akit érdekel az IoT vagy az otthoni elektronikai barkácsolás, az bizonyára hallott a <em>Raspberry Pi</em> eszközcsalád egyik tagjáról. Jelenleg a legnagyobb teljesítménnyel a <em>Raspberry Pi 3</em> rendelkezik. Azon kívül, hogy a nagy gyártói és közösségi támogatás miatt nagyon egyszerű ezeket az eszközöket felhasználni saját projektjeinkben, még nagyon jó áron is hozzájuk juthatunk. Akár Magyarországon is 15000 forintért<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a> kézhez kaphatunk egy <em>Pi 3</em>-at. Léteznek viszont olcsóbb testvérek is a <em>Pi 3</em>-hoz képest. Vegyük például a <em>Raspberry Pi Zero</em>-t, ami úgy híresült el, mint az első 5 amerikai dollárba kerülő számítógép a világon. <span class="citation">[RPI 1]</span> Azaz átszámolva 1500 forint környékén hozzájuthattunk egy olyan hardverhez, ami képes futtatni egy könnyedebb Linux disztribúciót és akár mindennapi irodai munkát is el lehet végezni rajta. Pontosan a fenti okok győztek meg arról, hogy egy ilyen eszköz teljes mértékben megfelel a hálózati réteg futtatásához. Illetve az is fontos döntési pont volt, hogy az általam választott <em>RF24Mesh</em> programkönyvtár teljes mértékben támogatja a <em>Raspberry Pi</em>-t.</p>
<h3 id="használat"><span class="header-section-number">4.3.1</span> Használat</h3>
<p>A <em>Raspberry Pi 3</em> annak ellenére, hogy olcsón beszerezhető, aránylag jó hardver konfigurációval rendelkezik. A központban egy <em>ARMv8</em> architektúrájú 64 bites processzor van, amely 4 darab 1.2GHz-es magból van felépítve. A processzor mellé 1 GB RAM van párosítva, amely bőven elég a legtöbb felhasználási módra. Mindemellett WiFi 802.11n és Bluetooth 4.1 LE képes az eszköz. <span class="citation">[RPI 2]</span></p>

<p>Ahhoz, hogy elkezdhessük használni szükségünk lesz egy SD kártyára, egy 5 voltos áramforrásra, egy HDMI képes monitorra és billentyűzetre, egérre. Az első lépés, hogy egy másik számítógéppel feltelepítsünk egy Linux disztribúciót az SD kártyára. Ajánlott magához a <em>Pi</em>-hez készített <em>Raspbian</em> Linuxot feltenni. Ha bele dugtuk az összes perifériát és az SD kártyát a <em>Pi</em>-be, majd áram alá helyezzük rövid időn belül egy teljes Linuxos felület fogad minket. <span class="citation">[RPI 3]</span></p>
<h3 id="raspberry-pi-foundation"><span class="header-section-number">4.3.2</span> Raspberry Pi Foundation</h3>
<p>A <em>Pi</em> eszközcsalád mögött a <em>Raspberry Pi Foundation</em> brit jótékonysági szervezet áll. Az a céljuk ezeknek a csodás eszközöknek a tervezésével, hogy olyan helyekre is eljuthasson a világon a technológia és annak tanítása, ahova pénzügyi okok miatt amúgy nem tudna. Rendkívül nagy sikerre tettek szert, hiszen több mint 10 millió <em>Pi</em> lett már értékesítve a világon és olyan cégekkel léptek partneri kapcsolatba, mint például a Microsoft. A sok munka, amit a platform fejlesztésével töltenek, viszont nem csak a világ szegényebb részeit segíti. Mivel ezek az eszközök egyszerűen használhatók, olcsóak és ráadásul nagy közösséget is tudtak maguk mögé állítani, akárki neki tud állni valamilyen elektronikai projektnek szabadidejében. <span class="citation">[RPI 4; RPI 5]</span></p>
<h2 id="szoftver-működés"><span class="header-section-number">4.4</span> Szoftver működés</h2>
<p>A hálózati réteg működése könnyen átlátható és annál is egyszerűbben implementálható. A fejezet korábbi részei alapján magától értetődő, hogy a program egyszerre kell kezeljen egy vezeték nélküli kapcsolatot az eszközökkel és egy TCP kapcsolatot a központi szerverrel. Ha ezt a két feladatot egy végrehajtási szálon szeretnénk elvégezni nagy eséllyel gondokba ütköznénk, aminek az lenne az oka, hogy az egyik kapcsolat eseményei nem lennének kellően lekezelve, amíg a másik kapcsolat kapja a figyelmet. Példa eset, az egyik kapcsolaton keresztül épp olvasás történik és a másikon üzenet érkezik. Viszont ez még nem azt jelenti, hogy a feladat megcsinálhatatlan egy futási szálon. Bizonyára lehetséges, de én úgy döntöttem, hogy teljesítményi okokból inkább kettő szálon kezelem a kapcsolatokat. A futtató hardverünk nem fog gátakat szabni e szempontból, tehát nyugodtan használhatunk szálkezelést.</p>

<p>Van akkor két végrehajtási szálunk, egy a TCP kapcsolatnak, egy a vezeték nélküli kapcsolatnak. Ha akármelyiken valamilyen üzenet érkezik, azt át kell alakítani a másik fél üzenetformájára és azon az oldalon tovább küldeni. Figyelnünk kell viszont, mivel, ha az egyik szál közvetlen bele szól a másik oldal kapcsolatába, könnyen lehet, hogy elrontja azt. Ami azt illeti elsőnek elkövettem ezt a hibát és nem is működött túl megbízhatóan a rendszer. Megoldani a problémát nem volt nehéz, hiszen elég volt mindkét szálon létrehozni egy listát, amelyben ideiglenesen el lesznek tárolva azok az üzenetek, amiket majd el kell küldeni. Vagyis, ha az egyik szálon érkezik egy üzenet, átalakítja azt, majd belerakja a másik szál listájába. Mikor a másik szál oda kerül, hogy üzeneteket küld, akkor kiveszi a listából a várakozó üzeneteket és kézbesíti. A listához való hozzáadás mindig lezárja a hozzáférést a másik oldal számára, így az csak akkor tudja olvasni és elküldeni az üzeneteket, ha senki nem ad hozzá éppen semmit. Ezzel így teljes mértékben megoldottuk a szálkezelést és minden üzenet szinte azonnal kézbesítésre kerül.</p>
<h3 id="programkönyvtárak"><span class="header-section-number">4.4.1</span> Programkönyvtárak</h3>
<p>Említésre került a fejezet elején, hogy a <em>Boost</em> könyvtárcsomag egy részét használtam a TCP kapcsolat irányítására. A <em>Boost.Asio</em> programkönyvtár adatok aszinkron feldolgozására van fejlesztve és többek között képes <code>socket</code>-ek kezelésére is. Mivel a <em>Boost</em> könyvtárcsomag, olyan nagy jelentőséggel bír a C++ fejlesztésben, hogy szinte egy kiterjesztett Standard könyvtárként lehet tekinteni rá, egyértelmű választás volt, mint TCP kapcsolatkezelő könyvtár. Jelentős könnyebbséget hoz a C-beli <code>socket</code> programozáshoz képest. Ahhoz, hogy teljesítse a feladatát a TCP kapcsolat kezelő végrehajtási szálunk elsőnek azt kell megnéznie, hogy van-e beérkező üzenetünk a központi szervertől. Ha van, akkor addig olvassuk a bejövő adatot, amíg nem találkozunk egy sorvége karakterrel, mert így jelöltem az üzenet végét. Ehhez a <code>boost::asio::read_until()</code> függvényt használtam. A beérkezett üzenetet átfuttatva az átalakító logikánkon belerakjuk a vezeték nélküli kapcsolatot kezelő szál listájába. Ha mindez meg volt vagy esetleg nem is volt beérkező üzenet, akkor megpróbáljuk elérni a saját elküldendő üzenet listánkat. Ennek sikere attól függ, hogy éppen történik-e módosítása a listának. Sikeres elérés esetén végig megyünk a listán és egyenként elküldünk minden üzenetet. A küldést a <code>boost::asio::ip::tcp::socket.write_some()</code> függvény segítségével lehet megvalósítani. <span class="citation">[BST]</span></p>
<p>A fenti logikához képest csak egy kicsivel van több dolga a vezeték nélküli kapcsolatot kezelő végrehajtási szálnak. Az előző alfejezetekből tudhatjuk már, hogy az eszközökkel való kommunikáció az <em>RF24Mesh</em> programkönyvtárnak köszönhető. A különbség a másik oldalhoz képest annyi, hogy az <em>RF24Mesh</em> esetén az érkező üzenetek beolvasását megbonyolítja az üzenetek címkézése. Már említettem, hogy ezeket a címkéket arra használjuk, hogy az eszközök kategóriáját (szenzor vagy aktor) meg tudjuk mondani. A beolvasás azzal kell kezdődjön, hogy megnézzük, milyen címkével rendelkezik az üzenet. Ez úgy történik, hogy az <code>RF24Network::peek()</code> függvény egy <code>RF24NetworkHeader</code> objektumba belerakja az üzenet fejléc részét. A fejléc rész olyan információkat tartalmaz, mint a küldő és a címzett hálózati címe, egy üzenet azonosító és az üzenet címke. Ezután a <code>RF24Network::read()</code> függvény a fejléc segítségével az teljes üzenetet belerakja egy általunk megadott változóba. Az olvasás befejezése után minden a TCP kapcsolat kezeléséhez hasonlóan zajlik, csak az üzenetküldéshez a <code>RF24Mesh::write()</code> függvényt kell használni. <span class="citation">[RF24 2; RF24 3]</span></p>
<h1 id="központi-rendszer"><span class="header-section-number">5</span> Központi rendszer</h1>
<p>Elértünk a teljes rendszer legfontosabb és legbonyolultabb részéhez, mivel, ahogy az gondolható a központi szerver kezel mindent. Itt történik az összes beérkező adat mentése, a felhasználói felületek biztosítása, az adatok alapján történő döntéshozás és a statisztikák elkészítése.</p>
<p>Az egyik lényegesebb döntést az adatbázis tekintetében kellett meghozni, hiszen a rendkívül nagy mennyiségű adatot el kell mentenünk. A kihívást az jelentette, hogy miként lehet kevés tárhely használatával eltárolni a látszólag kevés rendszerességet tartalmazó beérkező állapot jelentéseket. Tehát lesz szó arról, hogy milyen adatbáziskezelő rendszerek jöhettek szóba és melyiknek milyen előnyei, illetve hátrányai lettek volna a fejlesztésnél. Mivel már említettem a . alfejezetben, hogy a <em>MongoDB</em>-t választottam az adatok perzisztens tárolására, ezért kitérek majd arra is, hogy milyen séma alapján lesznek mégis rendszerezve az eszköz adatok és hogy miért jó az említett adatbáziskezelő rendszer az ilyen szituációkban.</p>
<p>Ahhoz, hogy a központi szerver létrejöhessen több keretrendszerre is szükségem volt. Így például a szerver alapját a <em>Spring</em> alkalmazásfejlesztési keretrendszer előre felkonfigurált verziója a <em>Spring Boot</em> adja. Nagy előnye a <em>Spring Boot</em>-nak, hogy nagyon gyorsan el lehet kezdeni fejleszteni az alkalmazás lényegi részét és nem kell sok időt tölteni a konfigurációval vagy éppen úgynevezett boilerplate kód írásával. A felhasználói felület megvalósításához a <em>Vaadin</em> webes UI keretrendszer volt segítségemre. Használata előre megírt komponensek felhasználásával felépített felületek tervezéséből áll. A <em>Vaadin</em> mellett szólt még, hogy könnyedén használható <em>Springes</em> webalkalmazások készítéséhez, mivel a készítők figyelmet fordítottak a kompatibilitásra és külön támogatják <em>Spring Boot</em> alapú webalkalmazások fejlesztését.</p>
<p>Nagy hangvételű részt kap a <em>Flow-rendszer</em>, hiszen csak említve voltak a fogalmak hozzá kapcsolódóan, viszont rendesen megmagyarázva nem. A <em>Flow-rendszer</em> felelős a felhasználó által megadott szabályok kezeléséért és betartásáért. A működés gyors menetének megtartásáért kellett alkalmazni néhány megoldást, amik akár gyorsítótáraknak is tekinthetőek, amelyekre azért volt szükség, hogy ne kelljen túl nagy terhelést rakni az adatbázisra feleslegesen, még akkor se, ha az adatbázis sokkal nagyobb terhelést is kibírna. Szintén lesz szó arról, hogy mi történik akkor, ha beérkezik új adat a rendszerbe, milyen folyamatok indulnak el.</p>
<h2 id="adatbázis"><span class="header-section-number">5.1</span> Adatbázis</h2>

<h3 id="adatbázis-kezelő-rendszer-kiválasztása"><span class="header-section-number">5.1.1</span> Adatbázis-kezelő rendszer kiválasztása</h3>
<p>Az adatbázis-kezelő rendszer megfelelő kiválasztása jelentős befolyással van arra, hogy a fejlesztés során mennyire lesz egyszerű dolgunk az adatkezeléssel. Pont ezért fontos, hogy jól végiggondolt döntést hozzunk, hiszen, ha a fejlesztés közben jövünk rá, hogy mégse a jó fejlesztői eszközt választottuk, akkor nehézkes és sok munkát igénylő lesz az átállás.</p>
<p>Mivel a rendszerbe folyamatosan temérdek mennyiségű adat érkezik és ezek az adatok nem éppen a legrendezettebbek vagy éppen sémába illeszthetőek, érdekes és újfajta kihívásokat jelentő feltételeknek kell megfelelnie a kívánt adatbázis-kezelő rendszer. Továbbá a beérkező adatok, amiket tárolni szeretnénk általában magukban értelmezhető kis egységeket alkotnak és így kevés vagy akár semennyi kapcsolat nem létezik köztük. Ezen okok miatt arra kellett jussak, mikor a megfelelő adatbázis-kezelő rendszer után kutattam, hogy egy relációs adatbázis egyáltalán nem lenne kedvező választás. Habár az ilyen típusú adatbázisok mára csodálatra méltó teljesítményre képesek és valószínűleg meg lehet oldani velük is alig rendezett adatok tárolását inkább a NoSQL adatbázisok felé tereltem figyelmemet.</p>
<p>A NoSQL adatbázisokról hallhattunk úgy, mint a modern kor adattárolásának megmentői, hiszen pont a régi, reláció alapú adatbázisok okozta problémákat próbálják orvosolni. Egyre több alkalmazás mögött áll elképesztő mennyiségű adat, aminek kezelése nagy kihívások elé állítja a fejlesztőket. Az egyik legfontosabb szemponttá vált a skálázhatóság az alkalmazások megtervezésénél és míg a relációs adatbázisok nehézkes és vertikális skálázhatóságot biztosítottak csak, addig a legtöbb NoSQL adatbázis beépítetten támogatja a horizontális skálázhatóságot. Ezt az előnyt tovább fokozza az a tény, hogy a szoftverfejlesztés egyre jobban halad a felhő alapú architektúrák használata felé, aminek jelentősen kedvez egy horizontálisan skálázható, sok csomópontból álló adatbázis klaszter.</p>
<p>NoSQL adatbázisokon belül is van többféle, lehet gráf adatbázis, kulcs-érték adatbázis vagy éppen dokumentumorientált adatbázis. Mindegyiknek meg van a maga előnye, például egy gráf adatbázisban könnyedén ábrázolhatunk kapcsolatokat, összefüggéseket az adataink között vagy egy dokumentumorientált tárolás esetén lehetőségünk van egy folyamatosan változó, sémamentes módon kezelni az adatainkat. A mi esetünkben megfelelő egy dokumentumorientált adatbázis használata, mert a sémamentes tárolás nagy szabadságot ad, amire szükségünk lesz az eszközöktől érkező állapotjelentő üzenetek strukturálatlansága miatt. <span class="citation">[DB 1; DB 2]</span></p>
<p>Tegyük fel, hogy mégis egy relációs adatbázisban szeretnénk tárolni az adatainkat, annak érdekében, hogy láthassuk milyen problémák lépnek fel és hogy a dokumentumorientáltság miért is kell számunkra. Tehát az a feladatunk, hogy a másodpercenként több eszköztől is érkező adatot egy táblában el legyenek mentve. Minden bejövő üzenet tartalmaz egy eszköz azonosítót, az eszköz típusát, az aktuális időpontot és egy mérési értéket. A legnaivabb megoldás az lenne, ha készítenénk erre egy táblát, ami pontosan ezeknek az adatoknak megfelelő típusú oszlopokat tartalmazza. Természetesen ez rendkívül tárhelyigényes megoldás lenne, hiszen feltételezve, hogy minden másodpercben csak egy eszköz küld mérési adatot, akkor körülbelül 11 nap futási idő után máris egy millió sort kellene kezeljünk a táblában. Ezt természetesen tovább rontja, hogy egynél több eszköz is lesz a rendszer által kezelve. Ráadásul, mivel az adat szinte csak ömlesztve van egy táblába hosszú és költséges lenne akármilyen lekérdezést is futtatni rajta. A hagyományos szemlélet szerint egy tábla valamely típus egyedeit tartalmazza, melyek relációban állnak más egyedekkel. Ezzel szemben jelen esetben a táblában tárolt adatok heterogének abban a tekintetben, hogy különböző típusú szenzorok mért értékeit írják le. Természetesen következik ebből, hogy hozzunk létre különböző táblákat a különböző eszköztípusok számára, vagy akár közvetlenül a különböző eszközök méréseinek tárolására. Ez azonban ahhoz vezetne, hogy dinamikusan kell táblákat létrehozni, új eszközök, vagy eszköztípusok hozzáadásakor. Ez viszont nem kívánatos. Illetve nincs is szükségünk arra, hogy az adataink relációban álljanak, hiszen az önmagában is értelmesek, ezért sem érdemes használjunk relációs adatbázist és inkább dokumentumorientált tárolásra lesz szükségünk.</p>
<p>Rengeteg dokumentumorientált NoSQL adatbázis létezik a világon, ezért csak arra a pár jelentősebbre fogok kitérni, amik illenek a mi használati esetünkhöz. Ezek név szerint a <em>MongoDB</em> és a <em>Couchbase</em> adatbázis-kezelő rendszerek, melyek rendre az 1. és a 3. legelterjedtebb dokumentumorientált adatbázisok a világon <span class="citation">[DB 3]</span>. A 2. helyen áll az Amazon által fejlesztett <em>DynamoDB</em>, ami csak azért marad ki, mert logikus módon erősen épít az Amazon által nyújtott felhőszolgáltatásokra és nem célunk, hogy ilyen felhő alapú rendszert készítsünk. A <em>MongoDB</em> és a <em>Couchbase</em> közötti első szembetűnő különbség az adatelérésben rejlik. A <em>MongoDB</em> SQL-hez hasonló lekérésekkel dolgozik kollekciókon, amik megfelelnek a relációs adatbázis tábláinak, a <em>Couchbase</em> esetében pedig különböző nézeteket határozhatunk meg előre, más-más szempont szerint. A <em>Couchbase</em> előre meghatározottságából adódik, hogy csak akkor érdemes használni, ha ritkán kell változtatni az adatok struktúráját és ha tudjuk előre, hogy mit és milyen formában szeretnénk lekérni az adatokat. Ezzel ellentétben áll a <em>MongoDB</em> rugalmas lekérdező nyelve, mely az SQL-hez hasonlóan tartalmaz logikai vagy éppen matematikai operátorokat. Illetve ezt a rugalmasságot kiegészíti még a <em>MongoDB</em> úgynevezett aggregációs keretrendszere, mely csővezetékszerűen egymás után kapcsolható szűrők és transzformációk végrehajtását teszi lehető az adatokon. Ez által aránylag kevés munka befektetésével hamar tudunk olyan lekérdezéseket írni, amiket felhasználva következtetéseket tudunk levonni az adataink alapján. <span class="citation">[DB 4; DB 5]</span></p>
<p>Ezek alapján úgy láttam, hogy a <em>MongoDB</em> lesz az az adatbázis-kezelő rendszer, ami legjobban kielégíti az igényeinket. Mivel aránylag közel áll a relációs adatbázisok fogalomvilágához, könnyedén át tudtam térni a használatára. Az aggregációs keretrendszer tökéletes eszköz akármilyen statisztika elkészítésére, amit a felhasználóknak megjelenítünk. Dokumentumorientáltságának és sémamentességének köszönhetően tudtam olyan tárolási megoldást találni, ami leegyszerűsíti a folyamatosan bejövő adat kezelését, de ezt majd a következő alfejezetben fogom részletezni.</p>
<h3 id="tárolási-séma"><span class="header-section-number">5.1.2</span> Tárolási séma</h3>
<p> A <em>MongoDB</em> egyszerre több adatbázist is tud kezelni, amelyek megegyeznek a relációs adatbázisoknál vett adatbázisok fogalmával. Az adatbázisokon belül kollekcióba szerveződnek a dokumentumaink, tehát a kollekciók megfeleltethetőek a tábláknak és a dokumentumok a tábla sorainak. A különbség az, hogy a dokumentumok felépítésének nem szükséges megegyezniük egy kollekción belül. Egy dokumentum kulcs-érték párokból áll, ahol a kulcs mindig egy sztring, az érték pedig lehet a többféle adattípus közül egy, tömb vagy akár dokumentum is. Ezzel az eszköz készlettel képesek vagyunk könnyedén olyan dokumentumokat alkotni, amik magukban alkotnak független egységet.</p>
<p>Legegyszerűbben egy példán keresztül lehet bemutatni, hogy milyen struktúrát választottam az adatok elmentéséhez. Minden dokumentum egy eszköz egy órányi adatát reprezentálja percenkénti átlagok formájában. A percenkénti átlag tárhely spórolási okokból lett bevezetve és nincs is szükségünk 10 másodpercenkénti mérések tárolására. Tehát egy dokumentum tárolja az adatot szolgáltató eszköz azonosítóját, típusát, a küldés dátumot, amit órákra van csonkolva és egy tömböt, amiben a percenkénti átlagok vannak. Minden tömb elem tárolja, hogy melyik percet reprezentálja, hogy abban a percben hány mérés érkezett és a mérések összegét. A . ábrán látható dokumentum egy hőmérőtől származó adatokat tárolja, ahol az küldő eszköz azonosítója <code>4</code> és az adatokhoz tartozó dátum <code>2017-01-01 12:00</code>. Látható, hogy csak a 30. és 31. percről vannak méréseink, még pedig mindkét esetben 6 darab. Logikusan a percekre lebontott átlag hőmérséklet úgy jön ki, ha a <code>sum</code> értékét elosztjuk a <code>num</code> értékével.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">{</span>
        <span class="st">&quot;_id&quot;</span> <span class="op">:</span> <span class="at">ObjectId</span>(<span class="st">&quot;587b98c8ffea6d2aece24250&quot;</span>)<span class="op">,</span>
        <span class="st">&quot;dev_id&quot;</span> <span class="op">:</span> <span class="dv">4</span><span class="op">,</span>
        <span class="st">&quot;date_hour&quot;</span> <span class="op">:</span> <span class="at">ISODate</span>(<span class="st">&quot;2017-01-01T12:00:00Z&quot;</span>)<span class="op">,</span>
        <span class="st">&quot;type&quot;</span> <span class="op">:</span> <span class="st">&quot;temperature&quot;</span><span class="op">,</span>
        <span class="st">&quot;values&quot;</span> <span class="op">:</span> [
                <span class="op">{</span>
                        <span class="st">&quot;minute&quot;</span> <span class="op">:</span> <span class="dv">30</span><span class="op">,</span>
                        <span class="st">&quot;num&quot;</span> <span class="op">:</span> <span class="dv">6</span><span class="op">,</span>
                        <span class="st">&quot;sum&quot;</span> <span class="op">:</span> <span class="fl">127.50000495910645</span>
                <span class="op">},</span>
                <span class="op">{</span>
                        <span class="st">&quot;minute&quot;</span> <span class="op">:</span> <span class="dv">31</span><span class="op">,</span>
                        <span class="st">&quot;num&quot;</span> <span class="op">:</span> <span class="dv">6</span><span class="op">,</span>
                        <span class="st">&quot;sum&quot;</span> <span class="op">:</span> <span class="fl">128.388999809265137</span>
                <span class="op">}</span>
        ]
<span class="op">}</span></code></pre></div>

<p>Az az előnye ennek a sémának egy olyan sémával szemben, ahol egy mérés egy dokumentum lenne, hogy a <em>MongoDB-ben</em> sokkal jobb egy dokumentumot frissíteni, mint mindig újat létrehozni. Ez részben abból ered, hogy jelentősen kevesebb dokumentumot kell egyszerre beolvasni a memóriába, illetve kevesebb tárhelyet is foglalnak maguk a dokumentumonként generált azonosítók is. Nem beszélve arról, hogy ezzel az összevont sémával nem kell mindig eltárolni például az küldő eszköz adatait. Továbbá a percenkénti összegzés elvégzése az adat mentésénél kevesebb számítási erőforrást igényel, mintha akkor kéne összeadni az egybe tartozó értékeket és elosztani a darab számmal, mikor lekérnénk statisztikákat. Ezt a sémát a <em>MongoDB</em> egyik solution arhitectjének egy előadása alapján hoztam létre <span class="citation">[DB 6]</span>.</p>
<p>Eddig azt ismertettem miért kellett dokumentumorientáltnak lennie az adatbázisunknak, de korábban kiemeltem azt is, hogy a sémamentesség is remek előnyökkel járhat. Például változtatás esetén nem szükséges migrálni az adatokat az új rendszerbe. A fejlesztés során a sémamentességet explicit módon nem használtam ki, hiszen valamilyen szinten strukturálni tudtam az adatokat. Azonban volt eset arra, hogy fejlesztés közben kellett változtatni a struktúrán és meg tudtam tartani minden addigi eszköz mérést különösebb nehézség nélkül. Emellett jövőbeli fejlesztés során bármikor jöhet olyan eszköz, amelynek másféle tárolási mód kedvező. Ezen &quot;jövő-állósága&quot; miatt is döntöttem a sémamentesség mellett.</p>
<h2 id="keretrendszerek"><span class="header-section-number">5.2</span> Keretrendszerek</h2>
<h3 id="spring-boot"><span class="header-section-number">5.2.1</span> Spring Boot</h3>
<p>A teljes szerver architektúrális alapját a <em>Spring Boot</em> adja, amely a <em>Spring</em> alkalmazásfejlesztési keretrendszer egy olyan verziója, ami előre megoldja nekünk a <em>Spring</em> konfigurációját. Természetesen ez csak úgy lehetséges, ha elfogadunk néhány konvenciót, hogy miként épüljön fel az elkészített alkalmazásunk. A fő célja a <em>Spring Bootnak</em>, hogy a fejlesztés a lehető leghamarabb elérje azt a fázist, ahol már az alkalmazás logikát lehet készíteni. Java webalkalmazások fejlesztésénél időről-időre előfordul, hogy nagyon hasonló kódot kell írni bizonyos háttérműködések futásához. Ezen boilerplate kód írásának a kihagyása sok időt és ezáltal pénzt tud megspórolni vállalati fejlesztési környezetben. Én is azért választottam a <em>Spring Bootot</em>, mert csak arra kellett figyeljek, ami lényeges volt a szerver működésének szempontjából és így nem vesztegettem az örökké szűkös fejlesztési időt.</p>
<p>A <em>Spring</em> keretrendszer magában nem több olyan konfigurációs és programozási modelleknél, amik hasznosak tudnak lenni Java-alapú vállalati alkalmazások fejlesztésénél. Önmagában a <em>Spring</em> olyan feladatokat lát el számunkra, mint a tranzakció-kezelés, adatkapcsolat elérése, függőség kezelés és injektálás, illetve webes servletek létrehozása. Ezek közül számomra főleg a függőség injektálás és a webes servletek voltak nagy hasznomra, igaz a servletek esetében plusz absztrakciót ad a <em>Vaadin</em> keretrendszer. Azonban ez csak a <em>Spring</em> alapcsomagja, emellett léteznek olyan modulok hozzá, mint a <em>Spring Data</em>, amely többféle adatelérési technológiát tesz egységesen használhatóvá vagy éppen a <em>Spring Security</em>, ami gondoskodik az alkalmazásunk autentikációjáról és autorizációjáról. Ezeknek a moduloknak a segítségévél és az alap <em>Spring</em> csomaggal tudunk igazán gyorsan és könnyedén webalkalmazásokat létrehozni. <span class="citation">[SPR 1]</span></p>
<p>A <em>Spring Boot</em> tudja mindazt, amit fent leírtam és ahhoz, hogy használni tudjuk elég egy <em>Maven</em> függőséget és egy szülő projektet megadni a mi alkalmazásunk <code>pom.xml</code>-jében. Az . ábrán látható <code>pom.xml</code> részlet megadása mellett további <em>starter</em> függőségek hozzáadásával a már korábban említett külső modulokat is konfiguráció-mentesen tudjuk használni az alkalmazásunkban. Ha például a <em>Spring Data JPA</em> implementációjának <em>Spring Boot</em> verzióját szeretnénk hozzáadni az alkalmazásunkhoz, akkor a <code>spring-boot-starter-data-jpa</code> <em>Maven</em> függőségre lesz csak szükségünk. <span class="citation">[SPR 2]</span></p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;parent&gt;</span>
    <span class="kw">&lt;groupId&gt;</span>org.springframework.boot<span class="kw">&lt;/groupId&gt;</span>
    <span class="kw">&lt;artifactId&gt;</span>spring-boot-starter-parent<span class="kw">&lt;/artifactId&gt;</span>
    <span class="kw">&lt;version&gt;</span>1.5.3.RELEASE<span class="kw">&lt;/version&gt;</span>
<span class="kw">&lt;/parent&gt;</span>
<span class="kw">&lt;dependencies&gt;</span>
    <span class="kw">&lt;dependency&gt;</span>
        <span class="kw">&lt;groupId&gt;</span>org.springframework.boot<span class="kw">&lt;/groupId&gt;</span>
        <span class="kw">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="kw">&lt;/artifactId&gt;</span>
    <span class="kw">&lt;/dependency&gt;</span>
<span class="kw">&lt;/dependencies&gt;</span></code></pre></div>

<h3 id="vaadin"><span class="header-section-number">5.2.2</span> Vaadin</h3>
<p>A felhasználói felület teljes egészében a <em>Vaadin</em> UI keretrendszer segítségével lett összerakva. Azért összerakva, mivel a <em>Vaadin</em> egy komponens alapú rendszer, vagyis különféle előre elkészített felület darabok segítségével és Java kód írásával, rövid idő alatt komplex megjelenítést vagyunk képesek létrehozni az alkalmazásunkhoz. Például az . ábrán látható Java kódrészlet egy szöveg dobozt és egy gombot fog megjeleníteni a felületen. Észrevehetjük még, hogy a gomb kattintásának lekezelése is <em>Java-ban</em> van implementálva és nem valamilyen kliens-oldali nyelven. Ezt a <em>Vaadin</em> szerver-vezérelt fejlesztési modelljének köszönhetjük, ami azt jelenti, hogy a böngészőben futó kliens kód folyamatosan kommunikál a szerverrel <em>HTTP</em> vagy <em>WebSocket</em> üzenetek formájában. Tehát, ha a felhasználó rákattint a gombra, egy üzenet generálódik a szervernek a gomb lenyomásról és erre a szerver egy értesítés megjelenítési üzenetet küld vissza, amit a kliens egyből végrehajt. A szerver-vezérelt modell rengeteg előnnyel járhat, javíthatja akár az alkalmazásunk biztonságát vagy éppenséggel könnyen változtathatóvá teszi felületet működtető logikát. <span class="citation">[VAAD 1; VAAD 2]</span></p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">TextField</span> name = <span class="kw">new</span> <span class="bu">TextField</span>(<span class="st">&quot;Your Name&quot;</span>, <span class="st">&quot;Vaadin&quot;</span>);

<span class="bu">Button</span> greetButton = <span class="kw">new</span> <span class="bu">Button</span>(<span class="st">&quot;Greet&quot;</span>);
greetButton.<span class="fu">addClickListener</span>(event -&gt;
    <span class="bu">Notification</span>.<span class="fu">show</span>(<span class="st">&quot;Hello &quot;</span> + name.<span class="fu">getValue</span>());

VerticalLayout layout = <span class="kw">new</span> <span class="fu">VerticalLayout</span>(name, greetButton);</code></pre></div>

<p>Természetesen vannak bonyolultabb beépített komponensek, mint egy szövegdoboz, például lenyíló menük vagy akár táblázatok. Azonban, ha valamilyen oknál fogva nem találjuk a megfelelő komponenst, akkor sajátokat is létrehozhatunk. Az . ábrán a rendszer statisztikákért felelős felülete látható, aminek fejlesztése során szükségem volt egy idősor grafikont megjelenítő modulra. Egy kliens-oldali grafikonrajzoló külső programkönyvtár segítségével sikerült is létrehozni az egyedi grafikon megjelenítő komponenst. Ez a példa tökéletesen bemutatja a <em>Vaadin</em> rugalmasságát és könnyű bővíthetőségét.</p>

<p>Számomra azért volt jó választás a <em>Vaadin</em>, mert a komponens alapúsága tényleg egyszerűvé tette a felület létrehozását. Illetve, mivel teljes egészében <em>Java-ban</em> lehet fejleszteni, nem volt szükséges megtanuljak egy számomra teljesen új kliens-oldali nyelvet, mint például a <em>JavaScript</em>. A beépített komponensekhez előre meg voltak írva a kinézetek, így azzal se kellett sok időt vesztegessek, hogy a felület stílusát formázgassam.</p>
<h2 id="flow-rendszer-1"><span class="header-section-number">5.3</span> Flow rendszer</h2>
<p> A <em>Flow rendszer</em> legfontosabb elemei a már említett <em>flowk</em>, melyekre gondolhatunk úgy akár egy-egy szabályra. Ezek a szabályok két listából állnak, egy feltétel listából és egy hatás listából. A feltétel lista olyan kikötéseket tartalmaz, amik, ha teljesülnek, akkor végrehajtódik a <em>flow</em> hatás listája. A hatás lista pedig tekinthető egy akció sorozatnak, amit szekvenciálisan végigjárva megkapjuk, hogy mi kellett történjen a <em>flow</em> teljesülésének időpontjában.</p>
<p>A feltétel lista részei lehetnek például egyes eszközök állapotára vonatkozó megszorítások (pl.: 20°C-nál nagyobb a hőmérsékletet mutat a nappaliban elhelyezett hőmérő) vagy a felhasználó vagy külső rendszer által indított kérés az alkalmazáshoz (pl.: gombnyomás a kezelőfelületen vagy HTTP kérés egy bizonyos címen), illetve egyéb rendszer állapot feltétel (pl.: időponthoz kötődő feltétel). Fontos megjegyezni, hogy a feltétel lista elemei között logikai ÉS kapcsolat áll, tehát mindnek teljesülnie kell, ahhoz, hogy a <em>flow</em> hatása végrehajtódjon.</p>
<p>A hatás lista elemei között szerepelhetnek eszközöknek célzott állapot beállító parancs küldés (pl.: kapcsoljon fel egy lámpa), más rendszerhez történő kérés (pl.: HTTP kérés) és egyéb segéd akció (pl.: késleltetés). Ezeknek a hatás elemeknek egymás után történő végrehajtása adja az adott flow hatását.</p>
<p>Azonban a fejlesztési idő végessége miatt nem jutott idő az összes feltétel és hatás típus implementálására. A feltételek típusok közül az eszköz állapot megszorítások és a hatás típusok közül az eszköz állapot beállítások lettek megvalósítva. Szerencsére ezzel az egy-egy feltétel és hatás típussal is teljes mértékben működő képes a rendszer. Azzal, hogy például nincs lehetőség HTTP kérések indítására és fogadására csak annyit vesztettünk, hogy egyelőre nem tudunk külső rendszerekkel együtt dolgozni.</p>
<p>A rendszer célja az, hogy a <em>flowk</em> segítségével a felhasználó szabályokat/feladatokat tud leírni, amelyeket a rendszer majd végrehajt és így lehetséges lesz bizonyos házkörüli feladatok automatizálása. Azzal, hogy pár egyszerű <em>flowt</em> létrehozunk megkönnyíthetjük a mindennapjainkat. Elsőre mindig csak kényelmi funkciókra gondolnánk, amit elvégeztethetünk a rendszerrel (pl.: automatikusan lekapcsoló lámpák), viszont megfelelő mennyiségű idő feláldozása után jelentős pénzösszeget is megspórolhatunk (pl.: időzített fűtésrendszer, ami csak akkor fűt, ha otthon vagyunk).</p>
<p>Pár példa a rendszer használatára:</p>
<ul>
<li>ha adott szobában nincs érzékelt mozgás, akkor lekapcsolódik a villany</li>
<li>ha több hőmérő is alacsony értéket mutat, akkor automatikusan fentebb megy a fűtés</li>
<li>ha egy virág földje kiszáradna, akkor víz engedődik a virág alá</li>
<li>ha reggeli időpont van, akkor beindul a kávéfőző</li>
<li>ha a levegő szén-monoxid tartalma átlép egy határt, akkor elindul egy jelző berendezés</li>
<li>ha besötétedik és van mozgás, akkor a sötétítők leengednek és felkapcsol egy villany</li>
</ul>
<h3 id="flow-végrehajtás"><span class="header-section-number">5.3.1</span> Flow végrehajtás</h3>
<p>A <em>Flow rendszer</em> működésének talán legizgalmasabb része a folyamatos ellenőrzés, hogy melyik <em>flow</em> lett aktív egy éppen beérkezett üzenet hatására. Az első megoldás, ami eszünkbe juthat, hogy egy végtelen ciklusban futna egy ellenőrző algoritmus, de tudjuk, hogy nem ez a legelegánsabb megoldás. Jelen esetben viszont csak állapot jelentés üzenetek formájában érheti a rendszert olyan külső hatás, ami miatt le kell ellenőrizni a <em>flowkat</em>. Ezért ahelyett, hogy lenne egy folyamatosan futó ellenőrző algoritmusunk sokkal hatékonyabb megoldást jelent az, ha az állapot jelentés üzenetek beérkezése váltaná ki az ellenőrzés egyszeri lefutását. Ezzel a mechanikával nem fektetünk folytonosan magas terhelést a futtató hardverre és adatbázisra.</p>
<p>Azzal, hogy csak beérkező adat esetén indítunk ellenőrzést tovább egyszerűsíthetjük a helyzetünket. Ha egy üzenet érkezik természetesen azt is tudjuk, hogy melyik eszköz küldte. Ezen plusz információ segítségével akár célirányosan tudjuk ellenőrizni azokat a <em>flowkat</em>, amikben &quot;szerepel&quot; a küldő eszköz. Egy eszköz akkor &quot;szerepel&quot; egy <em>flowban</em>, ha annak a <em>flownak</em> a feltétel listája tartalmaz, olyan megszorítást, ami az adott eszköz állapotára vonatkozik. Tehát egy beérkezett állapot jelentés hatására csak azokat a <em>flowkat</em> kell megnézni, hogy aktívak lettek-e, amelyeknek a feltétel listájában van hivatkozás az üzenetet küldő eszközre. Ezen egyszerűsítés hatására jelentősen kevesebb <em>flowt</em> kell végignézzünk, hogy végre kell-e hajtani.</p>
<p>Ha tovább szeretnénk optimalizálni az ellenőrzés folyamatát, még van rá lehetőségünk. Azzal, hogy célirányosan kérjük le a kiértékelendő <em>flowkat</em> az adatbázistól jelentős javulást értünk el az adatbázis terhelés tekintetében, de még mindig sok lehet, ha akár másodpercenként érkezik új adat. Valószínűleg ezen szintű terhelést nevetve kibírna a választott adatbáziskezelő rendszerünk, viszont mindig jobb előre megoldani problémákat, minthogy később valós gondokat szüljön. Ha bevezetünk egy gyorsítótárként funkcionáló mechanizmust tulajdonképpen teljesen megszüntethetjük az adatbázishoz irányuló azon lekérdezéseket, amik egy adott eszközhöz tartozó <em>flow</em> listát kérnek le. Ez a gyorsítótár egy olyan táblázat, melynek kulcsai az eszköz azonosítók és a kulcsokhoz tartozó értékek egy-egy listát tartalmaznak, melyekben a kulcsban szereplő eszközhöz tartozó <em>flowk</em> találhatóak. Lényegében listákat tartunk arról, hogy melyik eszköz állapot jelentése esetén melyik <em>flowkat</em> kell leellenőrizni. A listák frissen tartása se nagy feladat, hiszen egy <em>flow</em> csak akkor változhat, ha azt a felhasználó módosította. Ezáltal, ha egy <em>flowt</em> módosítanak vagy törölnek csak annyi a dolgunk, hogy kivesszük az összes gyorsítótár listából és végigfutva a feltétel listáján belerakjuk a megfelelő eszköz azonosítójú kulcshoz tartozó listába. Így már csak annyi dolgunk lesz egy állapot jelentés beérkezése esetén, hogy a gyorsító táblázatból lekérjük a küldő eszköznek megfelelő kulcs-érték párt és az abban lévő <em>flow</em> listát egyenként ellenőrizzük.</p>
<h3 id="flow-létrehozás"><span class="header-section-number">5.3.2</span> Flow létrehozás</h3>
<p>A <em>flow</em> létrehozás fejlesztése során több lehetőség közül kellett válasszak, melyek egymáshoz képest könnyebbek-nehezebbek voltak fejlesztési szempontból és felhasználó használati szempontból is. Megpróbáltam egy középutat találni a lehetőségek közt, hogy ne is legyen sok munkát igénylő fejlesztés és mégis hamar megérthető legyen a felhasználóknak.</p>
<p>A lehető legflexibilisebb beviteli módszer valamilyen egyedi programozási nyelvszerű bemenet lenne. Tehát lehetne egy saját szintaxisa annak, hogy miként kell megadni egy <em>flowt</em>. Ezzel a lehetőséggel inkább azokat a felhasználókat lehetne megcélozni, akik hajlandóak akár órákat is tölteni azzal, hogy megvalósítsák a maguknak tökéletes rendszert és ezért képesek lennének megtanulni egy rendkívül leegyszerűsített programozási nyelvet, amit csak erre a célra találtak ki. Természetesen ez nem mindenkinek megfelelő módja annak, hogy <em>flowt</em> hozzon létre, nem sokak akarnak ennyi időt elfecsérelni egyszerű szabályok létrehozására. De nem csak a felhasználó szemszögéből rendkívül bonyolult ez a bemenet, hanem fejlesztési szempontból is. Egy saját kódelemzőt kéne írni, ami képes lenne feldolgozni a neki beadott programot. Fel kellene oldani az eszköz neveket magukra az eszközökre vagy esetleg elvégezni matematikai feladatokat, amiket a felhasználó beleírhat a kódba. Sejthető, hogy nem ezt a megoldást választottam, mint végleges <em>flow</em> beviteli mód.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Nappali fűtés&quot;</span>
  <span class="dt">when</span><span class="op">:</span>
    <span class="st">&quot;Nappali hőmérő&quot;</span> is under <span class="st">&#39;20&#39;</span> AND
    TIME is later than <span class="dv">13</span><span class="op">:</span><span class="dv">50</span>
  <span class="dt">then</span><span class="op">:</span>
    set <span class="st">&quot;Nappali fűtés 1&quot;</span> to <span class="st">&#39;1&#39;</span><span class="op">,</span>
    set <span class="st">&quot;Nappali fűtés 2&quot;</span> to <span class="st">&#39;1&#39;</span>
<span class="op">}</span></code></pre></div>

<p>Ha a felhasználónak akarunk nagyon kedvezni, akkor létrehozhatnánk egy <em>drag'n'drop</em> felülettel a létrehozást. Minden feltétel vagy hatás típus a képernyő szélén létrehozhatnánk külön, majd behúzzuk egérrel oda, ahova szeretnénk tenni. Rendkívül átlátható lenne és pár perc alatt össze lehet rakni vele akár aránylag bonyolult szabályokat is. Ami mégis ezen mód ellen szól, hogy elég bonyolult feladat lehet a felületen ezt megvalósítani. Sajnos a felületet kezelő <em>Vaadin</em> keretrendszer nem támogat egyszerű <em>drag'n'drop</em> elemeket, ezért úgy döntöttem, hogy ez a bemeneti mód se felel meg elvárásaimnak. Túl bonyolult és aránytalanul hosszas lett volna implementálni számomra a rendszer többi részéhez képest.</p>
<p>Végül egy olyan felülettel oldottam meg a problémát, ahol egy-egy oszlop jelképezi a feltételek és hatások listáját minden <em>flowban</em> egyenként. A . ábrán látható egy példán keresztül is. Az oszlopokba egyesével lehet hozzáadni és törölni a feltételeket és hatásokat. Mivel minden feltétel vagy hatás típusnak más bemenetekre van szüksége, ezért ahogy változtatjuk egy feltétel vagy hatás típusát, úgy változik a mellette megjelenő bemeneti mezők kinézete is. Meg lehet még adni egy rendezési számot is, ami amolyan prioritási sorrendnek tekinthető. Erre azért van szükség, ha egy beérkező adat kivált több <em>flow</em> végrehajtást is, akkor ne nem-determinisztikus sorrendben lesznek lefuttatva, hanem elsőnek a kisebb rendezési számmal rendelkező és felfele haladva a többi.</p>

<h1 id="összefoglalás"><span class="header-section-number">6</span> Összefoglalás</h1>
<p>A dolgozatban egy otthon automatizációs rendszer felépítését és a fejlesztési döntéseket ismertettem. A célja a munkámnak az volt, hogy a rendszerhez kapcsolódó érzékelőktől kezdve, a központi adatgyűjtő és döntéshozó rendszerig minden általam legyen megtervezve és implementálva. A rendszer képes a felhasználó által megadott szabályok mentén irányítani egy teljes háztartást. Ehhez a házban és környékén elhelyezett érzékelő eszközök által szolgáltatott mérési adatokat használja fel. Az adatokat nem csak döntéshozási célokra használja a rendszer, hanem el is menti, hogy a felhasználó számára esetleges statisztikákkal tudjon szolgálni. Mindezt a felhasználó egy webes felületen keresztül tudja irányítani.</p>
<p>Elsőnek áttekintés céljából ismertettem nagy vonalakban a teljes rendszert és annak három nagyobb alrétegét. A három réteg az érzékelőkből és más funkciókkal bíró eszközökből, egy hálózati összekötő rétegből és egy központi szerverből áll. Az eszközök áttekintésénél megtudtuk, hogy mik a <em>szenzorok</em> és <em>aktorok</em>, illetve azt is, hogy hogyan kell működjenek. A hálózati réteg áttekintésében megindokoltam, hogy miért is van szükség egy ilyen közvetítő rétegre és azt is meg tudhattuk, hogy hardverközelségi igények miatt ez a réteg C++-ban lett fejlesztve. A központi szerver áttekintése során felvázoltam a rendszer lényegi részétől elvárt funkciók, mint például a statisztika megjelenítés vagy az eszközök élő irányítása.</p>
<p>Ezek után egyenként minden rétegről bővebben is esett szó, ahol már a fejlesztés során felmerülő döntéshelyzeteket is ismertettem. Természetesen minden döntés mellé indoklás is került, hogy miért azt az adott választást láttam legoptimálisabbnak a fejlesztés alatt.</p>
<p>Az eszközökről szóló fejezet egyik legfontosabb része a megfelelő hardverek kiválasztásáról szólt. Megindokoltam, hogy miért az <em>Arduino</em> platformot választottam az eszközök alapjaként és azt is, hogy miért az <em>nRF24L01+</em> alapú vezeték nélküli adó-vevő modulok kaptak szerepet. Ezek mellett azt is bemutattam, hogy hogyan oldottam meg az eszközökön futó szoftver működését hardveres megszakítások és az <em>AVR</em> mikrokontrollerek alvó állapotának segítségével.</p>
<p>Ahogy, az eszközök részletes bemutatása meg volt, a hálózati réteg következett. Ebben a fejezetben végig vettem azt, hogy miként épül fel egy <em>mesh</em> topológiájú hálózat és milyen előnyei vannak. Erre azért volt szükség, mert az eszközeink és a központi szervert képviselő csomópont egy mesh hálózatot alkotnak. Itt a központi csomópont egy átjáróként szolgál az eszközök és a szerver között. Ehhez egy külső programkönyvtárt használtam, ami kifejezetten az általunk választott <em>nRF24L01+</em> vezeték nélküli modulhoz fejlesztettek. Bemutattam, hogy miként működik a <em>TCP</em> kapcsolat és hogyan épülnek fel a JSON üzenetek a központi szerver és a hálózati réteg között, illetve ugyanúgy a hálózati réteg és az eszközök közötti kapcsolat is, ami már vezeték nélküli összeköttetésen történik. Részletesen belementünk abba, hogy miért is volt szükség többszálúságra, ahhoz, hogy egyszerre mindkét kapcsolatot kezeljük, illetve a kapcsolatot fenntartó technológiákat is röviden átnéztük. Különlegessége még a hálózati rétegnek, hogy egy <em>Raspberry Pi</em>-n fut az említett hardverközeli igények miatt.</p>
<p>A dolgozatom végére került a rendszer legfontosabb részének ismertetése. A központi szerver végzi el az összes valódi funkciót, értve ez alatt az adatok megfelelő elmentését, megjelenítését vagy a felhasználói szabályok betartatását. A folyamatosan beérkező adatok kezelése számomra újfajta kihívásokat jelentettek, aminek legyőzésére egy <em>NoSQL</em>, dokumentumorientált adatbázist a <em>MongoDB</em>-t választottam. A <em>MongoDB</em> segítségével könnyedén tudtam olyan tárolási sémát találni, amelynek köszönhetően megfelelő gyorsasággal tudok lekérdezéseket futtatni az adatokon és az adatok mentése se igényel rendkívül nagy tárhelyet. Azt is bemutattam, hogy a <em>flow rendszernek</em> elnevezett szabály végrehajtó rendszerem hogyan működik és hogy miként tudtam elkerülni a bejövő adatok folyamatos figyelését úgy, hogy mégis azonnal végrehajtódjon egy adott szabály következménye, ha annak előfeltétele teljesül.</p>
<p>Összességében meg tudtam valósítani azokat a funkcionalitásokat, amiket kitűztem magamnak célként, viszont rengeteg irányba lehetne még tovább fejleszteni a rendszert. Nem véletlen, hogy napjaink legnagyobb vállalatai is az <em>IoT</em>, illetve az otthon automatizálás témájával foglalkoznak, hiszen még nagyon sok fejlődésre van lehetősége az informatika ezen ágának. Magam is tervezem tovább bővíteni még a rendszer tudását szabadidőmben. Rengeteg eszköztípus van, amit még meg lehetne valósítani és egyelőre nem volt még hozzá szerencsém, de a más rendszerekkel való összekötés lehetősége is nagyon ígéretes lehet.</p>
<h1 id="köszönetnyilvánítás" class="unnumbered">Köszönetnyilvánítás</h1>
<p>Szeretném megköszönni Vágner Anikó Szilvia Tanárnőnek a mérhetetlen sok segítséget nyújtó megbeszéléseket, illetve azt, hogy bármikor kérdéseim voltak, azonnal választ kaptam rájuk akár személyesen, akár e-maileken keresztül tettem fel őket.</p>
<p>Nagy hálával tartozom még barátaimnak, akik nem hagyták, hogy csökkenjen lelkesedésem a téma iránt és a dolgozat elkészítése során végig kerítettek időt arra, hogy segítségemre legyenek.</p>
<p>Köszönöm még családomnak és barátnőmnek a folyamatos támogatásukat, illetve, hogy elnézték nekem az éjszakákba nyúló fejlesztési és írási munkámat. </p>

<!--
Do not edit this page.

References are automatically generated from the BibTex file (References.bib)

...which you should create using your reference manager.
-->
<h1 id="irodalomjegyzék" class="unnumbered">Irodalomjegyzék</h1>
<div id="refs" class="references">
<div id="ref-ArduinoIntro">
<p>[ARD 1]<em> Arduino Introduction</em> URL: <a href="https://www.arduino.cc/en/guide/introduction" class="uri">https://www.arduino.cc/en/guide/introduction</a> (2017. április 24)</p>
</div>
<div id="ref-ArduinoFAQ">
<p>[ARD 2]<em> Arduino FAQ</em> URL: <a href="https://www.arduino.cc/en/Main/FAQ" class="uri">https://www.arduino.cc/en/Main/FAQ</a> (2017. április 24.)</p>
</div>
<div id="ref-AvrGpp">
<p>[ARD 3]<em> AVR Libc User Manual FAQ</em> URL: <a href="http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_cplusplus" class="uri">http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_cplusplus</a> (2017. április 24.)</p>
</div>
<div id="ref-ButtonCell">
<p>[NRF 1]<em> Energizer CR2032 Datasheet</em> URL: <a href="http://data.energizer.com/pdfs/cr2032.pdf" class="uri">http://data.energizer.com/pdfs/cr2032.pdf</a> (2017. április 24.)</p>
</div>
<div id="ref-NRF24Range">
<p>[NRF 2]<em> Range Testing for Wireless Arduino Projects: RF 433 MHZ and NRF24L01+</em> URL: <a href="https://n8henrie.com/2015/03/range-testing-for-wireless-arduino-projects-rf-433-mhz-and-nrf24l01/" class="uri">https://n8henrie.com/2015/03/range-testing-for-wireless-arduino-projects-rf-433-mhz-and-nrf24l01/</a> (2017. április 24.)</p>
</div>
<div id="ref-NRF24Spec">
<p>[NRF 3]<em> nRF24L01+ Product Specification</em> URL: <a href="http://www.nordicsemi.com/eng/nordic/content_download/2726/34069/file/nRF24L01P_Product_Specification_1_0.pdf" class="uri">http://www.nordicsemi.com/eng/nordic/content_download/2726/34069/file/nRF24L01P_Product_Specification_1_0.pdf</a> (2017. április 24.)</p>
</div>
<div id="ref-ESP8266Range">
<p>[ESP 1]<em> Hackaday - ESP8266 Distance Testing</em> URL: <a href="http://hackaday.com/2014/09/26/esp8266-distance-testing/" class="uri">http://hackaday.com/2014/09/26/esp8266-distance-testing/</a> (2017. április 24.)</p>
</div>
<div id="ref-ESP8266PowerSpike">
<p>[ESP 2]<em> ESP8266 áramfogyasztás GitHub issue</em> URL: <a href="https://github.com/esp8266/Arduino/issues/2111#issuecomment-224251391" class="uri">https://github.com/esp8266/Arduino/issues/2111#issuecomment-224251391</a> (2017. április 24.)</p>
</div>
<div id="ref-ESP8266Spec">
<p>[ESP 3]<em> ESP8266EX Datasheet</em> URL: <a href="http://espressif.com/sites/default/files/documentation/0a-esp8266ex_datasheet_en.pdf" class="uri">http://espressif.com/sites/default/files/documentation/0a-esp8266ex_datasheet_en.pdf</a> (2017. április 24.)</p>
</div>
<div id="ref-ZigbeeDatasheet">
<p>[ZIG]<em> XBee Module Datasheet</em> URL: <a href="https://www.sparkfun.com/datasheets/Wireless/Zigbee/XBee-Datasheet.pdf" class="uri">https://www.sparkfun.com/datasheets/Wireless/Zigbee/XBee-Datasheet.pdf</a> (2017. április 24.)</p>
</div>
<div id="ref-DHT22Datasheet">
<p>[DHT]<em> DHT22 Humidity &amp; Temperature Sensor Datasheet</em> URL: <a href="https://cdn-shop.adafruit.com/datasheets/DHT22.pdf" class="uri">https://cdn-shop.adafruit.com/datasheets/DHT22.pdf</a> (2017. április 24.)</p>
</div>
<div id="ref-SPIDatasheet">
<p>[SPI]<em> SPI Block Guide</em> URL: <a href="https://web.archive.org/web/20150413003534/http://www.ee.nmt.edu/~teare/ee308l/datasheets/S12SPIV3.pdf" class="uri">https://web.archive.org/web/20150413003534/http://www.ee.nmt.edu/~teare/ee308l/datasheets/S12SPIV3.pdf</a> (2017. április 24.)</p>
</div>
<div id="ref-Interrupt">
<p>[INT 1]<em> Interrupts might seem basic, but many programmers still avoid them</em> URL: <a href="http://www.sltf.com/articles/pein/pein9505.htm" class="uri">http://www.sltf.com/articles/pein/pein9505.htm</a> (2017. április 24.)</p>
</div>
<div id="ref-AtmegaInterrupt">
<p>[INT 2]<em> Atmega328P Microcontroller Datasheet</em> URL: <a href="http://www.atmel.com/images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet_Complete.pdf" class="uri">http://www.atmel.com/images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet_Complete.pdf</a> (2017. április 24.)</p>
</div>
<div id="ref-ArduinoPower">
<p>[ARD 4]<em> Power saving techniques for microprocessors</em> URL: <a href="http://www.gammon.com.au/power" class="uri">http://www.gammon.com.au/power</a> (2017. április 24.)</p>
</div>
<div id="ref-RF24Tuning">
<p>[RF24 1]<em> RF24Network - Performance and Data Loss: Tuning the Network</em> URL: <a href="http://tmrh20.github.io/RF24Network/Tuning.html" class="uri">http://tmrh20.github.io/RF24Network/Tuning.html</a> (2017. április 24.)</p>
</div>
<div id="ref-RpiZeroPrice">
<p>[RPI 1] URL: <a href="https://www.raspberrypi.org/blog/raspberry-pi-zero/" class="uri">https://www.raspberrypi.org/blog/raspberry-pi-zero/</a> (2017. április 24.)</p>
</div>
<div id="ref-Rpi3Spec">
<p>[RPI 2]<em> Raspberry Pi 3 Hardware Specification</em> URL: <a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/" class="uri">https://www.raspberrypi.org/products/raspberry-pi-3-model-b/</a> (2017. április 24.)</p>
</div>
<div id="ref-RpiSetup">
<p>[RPI 3]<em> Raspberry Pi Documentation - Setup</em> URL: <a href="https://www.raspberrypi.org/documentation/setup/" class="uri">https://www.raspberrypi.org/documentation/setup/</a> (2017. április 24.)</p>
</div>
<div id="ref-RaspberryFoundation">
<p>[RPI 4]<em> Raspberry Pi Foundation - About Us</em> URL: <a href="https://www.raspberrypi.org/about/" class="uri">https://www.raspberrypi.org/about/</a> (2017. április 24.)</p>
</div>
<div id="ref-Rpi10M">
<p>[RPI 5]<em> Ten millionth Raspberry Pi, and a new kit</em> URL: <a href="https://www.raspberrypi.org/blog/ten-millionth-raspberry-pi-new-kit/" class="uri">https://www.raspberrypi.org/blog/ten-millionth-raspberry-pi-new-kit/</a> (2017. április 24.)</p>
</div>
<div id="ref-BoostAsioDocumentation">
<p>[BST]<em> Boost.Asio Reference Documentation 1.63</em> URL: <a href="http://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio/reference.html" class="uri">http://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio/reference.html</a> (2017. április 19.)</p>
</div>
<div id="ref-RF24NetworkDocumentation">
<p>[RF24 2]<em> RF24Network Class Documentation</em> URL: <a href="http://tmrh20.github.io/RF24Network/classRF24Network.html" class="uri">http://tmrh20.github.io/RF24Network/classRF24Network.html</a> (2016. április 19.)</p>
</div>
<div id="ref-RF24MeshDocumentation">
<p>[RF24 3]<em> RF24Mesh Class Documentation</em> URL: <a href="http://tmrh20.github.io/RF24Mesh/classRF24Mesh.html" class="uri">http://tmrh20.github.io/RF24Mesh/classRF24Mesh.html</a> (2016. április 19.)</p>
</div>
<div id="ref-NoSQLExplain">
<p>[DB 1]<em> NoSQL Databases Explained</em> URL: <a href="https://www.mongodb.com/nosql-explained" class="uri">https://www.mongodb.com/nosql-explained</a> (2017. április 24.)</p>
</div>
<div id="ref-DocDBs">
<p>[DB 2]<em> Document Databases</em> URL: <a href="https://www.mongodb.com/document-databases" class="uri">https://www.mongodb.com/document-databases</a> (2017. április 24.)</p>
</div>
<div id="ref-DBEngines">
<p>[DB 3]<em> DB-Engines Ranking</em> URL: <a href="https://db-engines.com/en/ranking/document+store" class="uri">https://db-engines.com/en/ranking/document+store</a> (2017. április 22.)</p>
</div>
<div id="ref-MongoVsCouch">
<p>[DB 4]<em> NoSQL showdown: MongoDB vs. Couchbase</em> URL: <a href="http://www.infoworld.com/article/2613970/nosql/nosql-showdown--mongodb-vs--couchbase.html" class="uri">http://www.infoworld.com/article/2613970/nosql/nosql-showdown--mongodb-vs--couchbase.html</a> (2017. április 24.)</p>
</div>
<div id="ref-MongoAggregation">
<p>[DB 5]<em> MongoDB Manual - Aggregation</em> URL: <a href="https://docs.mongodb.com/manual/aggregation/" class="uri">https://docs.mongodb.com/manual/aggregation/</a> (2017. április 24.)</p>
</div>
<div id="ref-MongoPresentation">
<p>[DB 6]<em> MongoDB for Time Series Data</em> URL: <a href="https://www.mongodb.com/presentations/mongodb-time-series-data-part-1-setting-stage-sensor-management" class="uri">https://www.mongodb.com/presentations/mongodb-time-series-data-part-1-setting-stage-sensor-management</a> (2017. április 22.)</p>
</div>
<div id="ref-SpringGuide">
<p>[SPR 1]<em> Spring Framework</em> URL: <a href="https://projects.spring.io/spring-framework/" class="uri">https://projects.spring.io/spring-framework/</a> (2017. április 24.)</p>
</div>
<div id="ref-SpringBootGuide">
<p>[SPR 2]<em> Spring Boot</em> URL: <a href="https://projects.spring.io/spring-boot/" class="uri">https://projects.spring.io/spring-boot/</a> (2017. április 24.)</p>
</div>
<div id="ref-VaadinArchitecture">
<p>[VAAD 1]<em> Vaadin Architecture - Overview</em> URL: <a href="https://vaadin.com/docs/-/part/framework/architecture/architecture-overview.html" class="uri">https://vaadin.com/docs/-/part/framework/architecture/architecture-overview.html</a> (2017. április 24.)</p>
</div>
<div id="ref-VaadinHome">
<p>[VAAD 2]<em> Vaadin Framework</em> URL: <a href="https://vaadin.com/framework" class="uri">https://vaadin.com/framework</a> (2017. április 24.)</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ezt az elnevezést magam adtam, mivel nem találkoztam kutatásaim során más megfelelő elnevezéssel.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Arduino Uno klón: <a href="https://tinyurl.com/ArduinoUnoClone" class="uri">https://tinyurl.com/ArduinoUnoClone</a> (2017. április 11.)<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Eredeti Arduino Uno Magyarországon: <a href="https://tinyurl.com/ArduinoUnoHun" class="uri">https://tinyurl.com/ArduinoUnoHun</a> (2017. április 11.)<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>nRF24L01+ vezeték nélküli modul eBay ára: <a href="https://tinyurl.com/eBayNRF24" class="uri">https://tinyurl.com/eBayNRF24</a> (2017. április 18.)<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>ESP-01 WiFi modul külföldi webáruházi ára: <a href="https://www.sparkfun.com/products/13678" class="uri">https://www.sparkfun.com/products/13678</a> (2017. április 18.)<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Zigbee Series 1 1mW vezeték nélküli modul külföldi webáruházi ára: <a href="https://www.sparkfun.com/products/8665" class="uri">https://www.sparkfun.com/products/8665</a> (2017. április 18.)<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>DHT22 hő- és páratartalom érzékelő: <a href="https://www.adafruit.com/product/385" class="uri">https://www.adafruit.com/product/385</a> (2017. április 11.)<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>PIR mozgásérzékelő: <a href="https://www.adafruit.com/product/189" class="uri">https://www.adafruit.com/product/189</a> (2017. április 11.)<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Föld nedvességmérő: <a href="https://www.sparkfun.com/products/13322" class="uri">https://www.sparkfun.com/products/13322</a> (2017. április 11.)<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>Elektromos relé: <a href="https://www.sparkfun.com/products/13815" class="uri">https://www.sparkfun.com/products/13815</a> (2017. április 11.)<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>TMRh20 RF24Mesh programkönyvtárja: <a href="https://github.com/nRF24/RF24Mesh" class="uri">https://github.com/nRF24/RF24Mesh</a><a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>Raspberry Pi 3 magyarországi ár: <a href="https://malnapc.hu/yis/raspberry-pi-3-model-b" class="uri">https://malnapc.hu/yis/raspberry-pi-3-model-b</a> (2017. április 13.)<a href="#fnref12">↩</a></p></li>
</ol>
</div>
            </body>
</html>

