<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta http-equiv="Content-Style-Type" content="text/css" />
        <meta name="generator" content="pandoc" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                        <title></title>
        <style type="text/css">code{white-space: pre;}</style>
                            <style type="text/css">
            div.sourceCode { overflow-x: auto; }
            table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
              margin: 0; padding: 0; vertical-align: baseline; border: none; }
            table.sourceCode { width: 100%; line-height: 100%; }
            td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
            td.sourceCode { padding-left: 5px; }
            code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
            code > span.dt { color: #902000; } /* DataType */
            code > span.dv { color: #40a070; } /* DecVal */
            code > span.bn { color: #40a070; } /* BaseN */
            code > span.fl { color: #40a070; } /* Float */
            code > span.ch { color: #4070a0; } /* Char */
            code > span.st { color: #4070a0; } /* String */
            code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
            code > span.ot { color: #007020; } /* Other */
            code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
            code > span.fu { color: #06287e; } /* Function */
            code > span.er { color: #ff0000; font-weight: bold; } /* Error */
            code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
            code > span.cn { color: #880000; } /* Constant */
            code > span.sc { color: #4070a0; } /* SpecialChar */
            code > span.vs { color: #4070a0; } /* VerbatimString */
            code > span.ss { color: #bb6688; } /* SpecialString */
            code > span.im { } /* Import */
            code > span.va { color: #19177c; } /* Variable */
            code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
            code > span.op { color: #666666; } /* Operator */
            code > span.bu { } /* BuiltIn */
            code > span.ex { } /* Extension */
            code > span.pp { color: #bc7a00; } /* Preprocessor */
            code > span.at { color: #7d9029; } /* Attribute */
            code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
            code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
            code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
            code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
            </style>
                                            <style>
            body {
                font-family: Georgia;
                max-width: 800px;
                margin: 0 auto;
                line-height: 30px;
                font-size: 18px;
                padding-left: 350px;
                padding-right: 50px;
                color: #111;
            }
            
            h1, h2, h3, h4, h5, h6 {
                font-family: Arial;
            }
            
            h1 {
                padding-top: 200px;
                line-height: 50px;
            }
            h2 {
                padding-top: 30px;
            }
            h3 {
                padding-top: 20px;
            }
            h4 {
                padding-top: 10px;
            }
            p {
                text-align: justify;
            }
            p a {
                word-wrap: break-word;
                white-space: pre;
            }
            code {
                word-wrap: break-word;
            }
            blockquote {
                border-left: 3px solid #eee;
                margin-left: 20px;
                padding-left: 20px;
            }
            
            ::selection {
                background-color: #E4E4E4;
            }
            
            table {
                width: 100%;
            }
            table caption {
                font-weight: bold;
            }
            table tr {
                padding: 0;
                margin: 0;
                background-color: #f0f0f0;
            }
            table tr.even {
                background-color: #fafafa;
            }
            table td {
                margin: 0;
                padding: 3px 5px;
            }
            
            p span.added {
                color: green;
                background-color: #FFF3C5;
            }
            p span.removed {
                color: red;
                background-color: #FFF3C5;
            }
            
            #title-page {
                padding: 80px 0;
            }
            
            #TOC {
                position: fixed;
                left: 0;
                top: 0;
                overflow-y: scroll;
                height: 100%;
                background: #fafafa;
                max-width: 300px;
                font-family: Arial;
                font-size: 15px;
                line-height: 30px;
            }
            ::-webkit-scrollbar {
                width: 8px;
            }
            ::-webkit-scrollbar-track {
                background-color: #ECECEC;
            }
            ::-webkit-scrollbar-thumb {
                background-color: #B0B0B0;
                border-radius: 8px;
            }
            #TOC > ul {
                padding-right: 10px;
            }
            #TOC ul {
                list-style: none;
                padding-left: 20px;
            }
            #TOC ul li a {
                text-decoration: none;
                color: #364149;
                text-overflow: ellipsis;
                display: block;
                white-space: nowrap;
                overflow: hidden;
            }
            #TOC ul li a:hover {
                color: #008cff;
            }
            
            .figure {
                text-align: center;
            }
            .figure p {
                text-align: center;
                font-style: italic;
            }
            .figure img {
                  width: 100%;
            }
            </style>
                <script src="js/jquery.js"></script>
        <script src="js/diff.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
                <!--
                -->
        <div id="title-page">
            <h1>This is the title of the thesis</h1>
            <h2>Firstname Surname</h2>
        </div>
                    <div id="TOC">
                <ul>
                <li><a href="#köszönetnyilvánítás">Köszönetnyilvánítás</a></li>
                <li><a href="#bevezetés"><span class="toc-section-number">1</span> Bevezetés</a></li>
                <li><a href="#rendszer-áttekintés"><span class="toc-section-number">2</span> Rendszer áttekintés</a><ul>
                <li><a href="#eszközök"><span class="toc-section-number">2.1</span> Eszközök</a><ul>
                <li><a href="#szenzorok"><span class="toc-section-number">2.1.1</span> Szenzorok</a></li>
                <li><a href="#aktorok"><span class="toc-section-number">2.1.2</span> Aktorok</a></li>
                </ul></li>
                <li><a href="#hálózati-réteg"><span class="toc-section-number">2.2</span> Hálózati réteg</a></li>
                <li><a href="#központi-szerver"><span class="toc-section-number">2.3</span> Központi szerver</a><ul>
                <li><a href="#flow-rendszer"><span class="toc-section-number">2.3.1</span> Flow-rendszer</a></li>
                <li><a href="#statisztika"><span class="toc-section-number">2.3.2</span> Statisztika</a></li>
                <li><a href="#kezelőpanel"><span class="toc-section-number">2.3.3</span> Kezelőpanel</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#eszközök-1"><span class="toc-section-number">3</span> Eszközök</a><ul>
                <li><a href="#hardver-választás"><span class="toc-section-number">3.1</span> Hardver választás</a><ul>
                <li><a href="#arduino"><span class="toc-section-number">3.1.1</span> Arduino</a></li>
                <li><a href="#vezetéknélküli-modulok"><span class="toc-section-number">3.1.2</span> Vezetéknélküli modulok</a></li>
                <li><a href="#eszköz-specifikus-hardver"><span class="toc-section-number">3.1.3</span> Eszköz specifikus hardver</a></li>
                </ul></li>
                <li><a href="#felépítés"><span class="toc-section-number">3.2</span> Felépítés</a><ul>
                <li><a href="#példák-kész-eszközökre"><span class="toc-section-number">3.2.1</span> Példák kész eszközökre</a></li>
                </ul></li>
                <li><a href="#firmware-működés"><span class="toc-section-number">3.3</span> Firmware működés</a><ul>
                <li><a href="#megszakítások"><span class="toc-section-number">3.3.1</span> Megszakítások</a></li>
                <li><a href="#alacsony-fogyasztás"><span class="toc-section-number">3.3.2</span> Alacsony fogyasztás</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#hálózati-réteg-1"><span class="toc-section-number">4</span> Hálózati réteg</a><ul>
                <li><a href="#mesh-hálózat"><span class="toc-section-number">4.1</span> Mesh hálózat</a><ul>
                <li><a href="#felépítés-1"><span class="toc-section-number">4.1.1</span> Felépítés</a></li>
                <li><a href="#címzés"><span class="toc-section-number">4.1.2</span> Címzés</a></li>
                </ul></li>
                <li><a href="#üzenetek-felépítése"><span class="toc-section-number">4.2</span> Üzenetek felépítése</a><ul>
                <li><a href="#kommunkáció-a-központi-szerverrel"><span class="toc-section-number">4.2.1</span> Kommunkáció a központi szerverrel</a></li>
                </ul></li>
                <li><a href="#raspberry-pi"><span class="toc-section-number">4.3</span> Raspberry Pi</a><ul>
                <li><a href="#használat"><span class="toc-section-number">4.3.1</span> Használat</a></li>
                <li><a href="#raspberry-pi-foundation"><span class="toc-section-number">4.3.2</span> Raspberry Pi Foundation</a></li>
                </ul></li>
                <li><a href="#szoftver-működés"><span class="toc-section-number">4.4</span> Szoftver működés</a><ul>
                <li><a href="#programkönyvtárak"><span class="toc-section-number">4.4.1</span> Programkönyvtárak</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#központi-rendszer"><span class="toc-section-number">5</span> Központi rendszer</a><ul>
                <li><a href="#adatbázis"><span class="toc-section-number">5.1</span> Adatbázis</a><ul>
                <li><a href="#adatbázis-kiválasztása"><span class="toc-section-number">5.1.1</span> Adatbázis kiválasztása</a></li>
                <li><a href="#tárolási-séma"><span class="toc-section-number">5.1.2</span> Tárolási séma</a></li>
                </ul></li>
                <li><a href="#keretrendszerek"><span class="toc-section-number">5.2</span> Keretrendszerek</a><ul>
                <li><a href="#spring-boot"><span class="toc-section-number">5.2.1</span> Spring Boot</a></li>
                <li><a href="#vaadin"><span class="toc-section-number">5.2.2</span> Vaadin</a></li>
                </ul></li>
                <li><a href="#flow-rendszer-1"><span class="toc-section-number">5.3</span> Flow rendszer</a><ul>
                <li><a href="#flow-kiértékelés"><span class="toc-section-number">5.3.1</span> Flow kiértékelés</a></li>
                </ul></li>
                </ul></li>
                <li><a href="#teljesítmény"><span class="toc-section-number">6</span> Teljesítmény</a><ul>
                <li><a href="#hatótáv"><span class="toc-section-number">6.1</span> Hatótáv</a></li>
                <li><a href="#eszköz-szám"><span class="toc-section-number">6.2</span> Eszköz szám</a></li>
                <li><a href="#áteresztőképesség"><span class="toc-section-number">6.3</span> Áteresztőképesség</a></li>
                </ul></li>
                <li><a href="#biztonság"><span class="toc-section-number">7</span> Biztonság</a><ul>
                <li><a href="#megbízott-eszközök"><span class="toc-section-number">7.1</span> Megbízott eszközök</a></li>
                <li><a href="#titkosítás"><span class="toc-section-number">7.2</span> Titkosítás</a></li>
                <li><a href="#problémák"><span class="toc-section-number">7.3</span> Problémák</a></li>
                </ul></li>
                <li><a href="#összefoglalás"><span class="toc-section-number">8</span> Összefoglalás</a></li>
                <li><a href="#irodalomjegyzék">Irodalomjegyzék</a></li>
                </ul>
            </div>
                                

<p> </p>
<h1 id="köszönetnyilvánítás" class="unnumbered">Köszönetnyilvánítás</h1>



<h1 id="bevezetés"><span class="header-section-number">1</span> Bevezetés</h1>
<p>Dolgozatom témaválasztása nem volt nehéz feladat számomra, mivel korábbi érdeklődés alapján már találkoztam az otthon &quot;okosítás&quot; vagy automatizálás témakörével. Rendkívül le tudtak foglalni a hardverközeli, mikrokontrollereket felhasználó projektjeim és azoknak kapcsán kezdtem el például különböző környezeti jellemző mérőeszközöket készíteni szabadidőmben. Onnantól kezdve pedig rövid út vezet házak utólagos felokosításának ötletéhez. Foglalkoztat még az is, hogy milyen előnyei lehetnek egy okos otthon rendszernek. Természetesen az elsődleges dolog e szempontból a spórolás lehetősége. Mindenki szeretne lefaragni a számlák összegéből például a fűtés kikapcsolásával, mikor nem vagyunk otthon, vagy a lámpák automatikus lekapcsolásával, ha éppen nem vagyunk a szobában. Másik vonzó tulajdonsága egy okos otthonnak, hogy rengeteg kényelmi funkciót tud nyújtani. Gomb nyomásra leengedhetjük a ház összes sötétítőjét vagy a rendszer meglocsolhatja helyettünk a növényeket. Tervem, hogy ezt az általam fejlesztett rendszert a saját otthonomban használjam jelentős számú mérőeszközöket felhasználva.</p>
<p>Annak a háttérében, hogy mindezt a Java nyelv segítségével tervezem megvalósítani, szintén egyszerű okok állnak. Tanulmányaim során legtöbbször a Java nyelvvel találkozhattam és így szerezhettem jelentősebb belelátást a működésébe és használatába. Így mivel szinte egyedül a Java nyelvhez kapcsolódóan van megfelelő tudásom ahhoz, hogy szakdolgozathoz illő nagyságú munkát készítsek, azt választottam alapnak. Másik fontos oka választásomnak, hogy szakmai gyakorlatom alatt is Java nyelvet használtam és így tudtam ismereteket szerezni több olyan keretrendszerről, amiket használni is szeretnék tapasztalatszerzés céljából, illetve pontosan beleilletek a bennem kialakuló képbe, amit arról a rendszerről alkottam, mely ennek a dolgozatnak az alapját adja.</p>
<p>A dolgozatom során a fő cél egy olyan rendszer elkészítése, mely képes apró eszközök és egy központi egység segítségével automatizált feladatokat elvégezni. Ennek eléréséhez meg kellett tervezni az apró eszközök hardveres felépítését, fejleszteni egy központi szoftvert, ami képes az eszközöktől érkező adatok feldolgozására és azok alapján a felhasználó által megadott szabályok mentén feladatokat végrehajtására. Felmerült több érdekes kérdés is, melyekre kutatásaim során találtam válaszokat és próbáltam ezen válaszokat felhasználni a fejlesztés során.</p>
<p>A fejlesztés alatt végig úgy hoztam a döntéseket, hogy egy egyszerű háztartásban kell működjön a rendszer. Tehát nem volt célom az, hogy nagy számú felhasználók használják egyszerre vagy éppen több száz eszköz kapcsolódjon a központi rendszerhez. Részletesebben és feladathoz kapcsolódóan is meg fogom fogalmazni az elvárásokat, célokat a rendszerrel szemben, de ezt természetesen a későbbi fejezetekben teszem majd.</p>
<h1 id="rendszer-áttekintés"><span class="header-section-number">2</span> Rendszer áttekintés</h1>
<p>Ebben a fejezetben egy kezdeti képet szeretnék adni a teljes rendszer alapvető felépítéséről, illetve arról, hogy az egyes rendszer részek felé milyen elvárások vannak. Minden részt kifejtek ebben a fejezetben, de csak annyira, hogy átláthatóvá tegye a dolgozat többi részét. Későbbi fejezetekben viszont majd mélyrehatóbban nézzük meg a rendszer alapjait.</p>
<p>Alapvetően három részre bontható a rendszer:</p>
<ul>
<li>Eszközök, amely magába foglalja az összes mérőeszközt és egyéb kisebb beágyazott rendszereket. Ezek egyszerű mikrokontrollereket használó rendszerek, amiknek annyi szerepe van, hogy vagy adatot szolgáltatnak, vagy valamilyen funkcionalitást végeznek el.</li>
<li>Hálózati réteg, amely egy egyszerű közvetítőként funkcionál a központi szerver és az eszközök között. Lényegében átalakítja az üzeneteket a két rész között a megfelelő formátumra.</li>
<li>Központi szerver, amely végzi az adatok feldolgozását és biztosít egy felületet a felhasználó számára, hogy láthassa a rendszer állapotát vagy aktuális adatokat.</li>
</ul>

<h2 id="eszközök"><span class="header-section-number">2.1</span> Eszközök</h2>
<p>Mint már említve volt, ide tartoznak azok a hardverközeli rendszerek, amik vagy adatgyűjtő szerepet töltenek be, vagy valamilyen funkcionalitást képesek végrehajtani. Lehet egy ilyen eszköz például egy hőmérő, légnyomásmérő, földnedvességmérő vagy éppen egy relé.</p>
<p>Ezek az eszközök két csoportba sorolhatók:</p>
<ul>
<li>Érzékelők, másnéven <em>szenzorok</em> vagy</li>
<li>Cselekvők, másnéven <em>aktorok</em><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></li>
</ul>
<p>Valójában viszont ez a két csoport nem diszjunkt és később kiderül miért is nem, ha látjuk pontosan melyik mit jelent. Közös bennük, hogy mindegyikben van egy mikrokontroller és egy kommunikációért felelős modul. E mellett mindegyik eszköz tartalmaz még egy specifikus modult is, ami meghatározza, hogy mit is csinál az adott eszköz (pl.: hőmérő esetén egy hőmérséklet- és páratartalom érzékelő), illetve, hogy melyik csoportba tartozik.</p>
<h3 id="szenzorok"><span class="header-section-number">2.1.1</span> Szenzorok</h3>
<p>Magától értetődően a szenzorok felelősek az adatok szolgáltatásáért. Működését tekintve a mikrokontroller vezérli az adatgyűjtés és küldés folyamatát. Az idő nagy részében alvó állapotban van energiatakarékossági szempontok miatt, viszont fix időközönként felébred. Mikor felébred lekéri a saját specifikus moduljától a jelenlegi mért állapotot, majd azt megpróbálja közvetíteni a központba. Ezt addig próbálja, amíg nem sikerül, vagyis a központ vissza nem küld egy automatikus jelzést, hogy megérkezett az adat. Szenzorok közé sorolhatók például a sok féle mérőeszközök vagy akár egy mozgásérzékelő is.</p>
<h3 id="aktorok"><span class="header-section-number">2.1.2</span> Aktorok</h3>
<p>Az aktorok a rendszer olyan részei, amik segítségével a rendszer képes változtatásokat végbe vinni a fizikai világban. Hasonló a helyzet a szenzorok esetéhez, hiszen ugyanúgy a mikrokontroller kezel mindent. Ugyanúgy alvó állapotban van az eszköz az idő nagy részében, viszont jelen esetben nem fix időközönként ébred fel, hanem amikor üzenetet kap a központtól. Ezek az üzenetek állapot beállítási parancsok, vagyis utasítják az eszközt, hogy állítson át vagy cselekedjen valamit. Ha megtörtént a parancs feldolgozása, az eszköz egyből elküldi a központi rendszernek az új állapotát, állapotjelentés formájában, akárcsak a szenzorok, majd megint alvó állapotba kerül a következő parancsig. Aktor lehet például egy elektromos relé vagy egy termosztát is.</p>
<p>Tehát láthatjuk, hogy miért is nem szétválasztható a két csoport. Az aktorokra tekinthetünk olyan szenzorokként, amik képesek még egyéb funkcionalitást is végezni. Így tekintve a szenzorok csoportja tágabb és magába foglalja az aktorok csoportját.</p>
<h2 id="hálózati-réteg"><span class="header-section-number">2.2</span> Hálózati réteg</h2>
<p>A hálózati réteg léte elsőnek nem látszik logikusnak. Feleslegesnek tűnhet egy plusz szereplőt bevonni a központi szerver és az eszközök közé. A probléma, ami mégis megköveteli azt, hogy legyen egy köztes réteg, az egy eszközökhöz kötődő döntésből fakad.</p>
<p>A hardveres tervezés alatt találkoztam több vezetéknélküli kommunikációs modullal is. Volt olyan, ami WiFi-t használ a kommunikációhoz, volt, ami csak simán rádiófrekvenciás modul volt. Bizonyos okok miatt, amit majd a . alfejezetben fogok leírni, a rádiófrekvenciás modulok mellett döntöttem. Így viszont szükség van egy központi eszközre, ami egy ugyanolyan kommunikációs modullal kell rendelkezzen, mint a többi eszköz. Ahhoz, hogy ezt a modult használni tudjuk, viszont alacsonyabb szintű eszközökhöz kell folyamodni, mint amit a Java nyújtani tud. Pont ezért a hálózati réteg egésze C++-ban íródott.</p>
<p>Lényegében a hálózati réteg tartja fent a kapcsolatot az eszközökkel és alakítja át az üzeneteket a fogadó félnek megfelelő formátumra. Ez az alakítás azért szükséges, mert a kommunikáció a hálózati réteg és a központi szerver között egy TCP kapcsolaton keresztül történik JSON objektumok küldésével, viszont a hálózati réteg és az eszközök között C-beli <code>struct</code>-okat küldünk rádiófrekvenciás jelek segítségével.</p>
<h2 id="központi-szerver"><span class="header-section-number">2.3</span> Központi szerver</h2>
<p>A legnagyobb funkcionalitást természetesen a központi szerver végzi, hiszen ott lesznek feldolgozva az eszközöktől érkező állapotjelentések és a szerver küldhet állapot beállítási parancsokat is.</p>
<p>Mint említve volt már a központi szerver TCP kapcsolaton keresztül kommunikál a hálózati réteggel. Az onnan érkező üzeneteket a rendszer például a megfelelő formában elmenti az adatbázisban vagy az üzenet hatására elindulhat</p>
<p> A központi szervert is tovább tudjuk bontani több darabra funkcionalitása alapján:</p>
<ul>
<li>Flow-rendszer</li>
<li>Statisztika</li>
<li>Kezelőpanel</li>
</ul>
<h3 id="flow-rendszer"><span class="header-section-number">2.3.1</span> Flow-rendszer</h3>
<p>A <em>Flow-rendszer</em> onnan kapta a nevét, hogy a felhasználó által megadható szabályokat &quot;flow&quot;-knak neveztem el. A név a beérkező adatok folyamából és azoknak folyamatos feldolgozásából jön. Minden flownak van feltétele és hatása. Ez a hatás akkor fog bekövetkezni, ha a feltétel teljesül. Részletesebben a . alfejezetben lesz szó a flowkról.</p>
<p>A <em>Flow-rendszer</em> biztosítja az új szabályok létrehozásának, régebbiek módosításának lehetőségét és elmenti az így létrejött változásokat. Másik lényeges feladata ennek a rendszernek még, hogy be is tartassa ezeket a szabályokat. A szabályok betartásáért felelős mechanizmust szintén a . alfejezetben fogom taglalni. Röviden összefoglalva, ha új adat érkezik, a rendszer megnézi melyik szabályokat érintheti az esemény és kiértékeli azokat. Tulajdonképpen ez a rendszer felelős a szerver legfontosabb és legbonyolultabb funkcióiért.</p>
<h3 id="statisztika"><span class="header-section-number">2.3.2</span> Statisztika</h3>
<p>A rendszer használata során természetesen szeretnék néha visszanézni régebbi méréseket. Lehet ennek sok oka, például szeretnénk megnézni mennyivel volt hidegebb az előző hónapban, vagy leellenőrizhetjük mennyit volt bekapcsolva a fűtés. Tehát elég könnyen adja magát az elvárás, hogy tudjunk statisztikákat nézni a múltbeli adatokról.</p>
<p>Ehhez viszont el kell tárolni minden adatot, hogy később is tudjunk valamit mutatni a felhasználónak. Az adatbázis-rendszer kiválasztásánál ez volt az egyik legnagyobb szempont. A választás a <em>MongoDB</em>-re jutott, viszont a döntés mögött álló érveket majd a . alfejezetben fogom ismertetni. Mindemellett ahhoz, hogy az a sok adat, amit elmentenénk ne foglaljon sok tárhelyet, nem külön mentődnek el, ahogy beérkeznek a szerverhez, hanem percenként átlagolva kerül az adatbázisba. Ezzel igaz, hogy egy kicsi pontosságot vesztünk, mikor visszanézzük a statisztikákat, viszont, ha jobban belegondolunk nincs is szükségünk arra, hogy például 10 másodpercenkénti részekre lebontva lássuk a múlt heti hőmérsékletet. Ami azt illeti még a percenkénti lebontás is túl aprónak tűnik bizonyos helyzetekben, de természetesen a lementett adatok segítségével elő tudunk állítani akár napi vagy havi átlagokat is. Mindezt grafikonokon és idő-soros diagrammokon mutatva, a felhasználó könnyedén tud következtetések levonni magának.</p>
<h3 id="kezelőpanel"><span class="header-section-number">2.3.3</span> Kezelőpanel</h3>
<p>A kezelőpanel szolgáltatja a felhasználó számára a valós idejű adatokat. Itt jelennek meg a beérkező állapotjelentések az eszközöktől legelőször, illetve aktorok esetében itt lesz lehetőségünk kézzel átállítani az eszköz állapotát, vagyis állapot beállító parancsokat küldeni.</p>
<p>Lehetővé válik így, hogy a felhasználó akár a munkahelyéről is megnézhesse, hogy áll az otthona, esetleg nem hagyta-e nyitva az ajtót reggel. Ez a pár másopercenként frissülő kezelő felület minden eszköztípushoz külön mini megjelenítő modulokat rendel, aminek köszönhetően akár pár pillanat alatt megtalálhatjuk a számunkra fontos információkat.</p>
<h1 id="eszközök-1"><span class="header-section-number">3</span> Eszközök</h1>
<p>Az előző fejezetben megtudtuk, mit csinálnak az eszközeink. Szintén megismertük, hogy mit is jelent a <em>szenzor</em> és az <em>aktor</em> fogalma, illetve, hogy miben különböznek. Ebben a fejezetben ecsetelve lesz, milyen hardverek lettek kiválasztva az eszközök összeállítására, illetve meg lesznek indokolva ezen választások is.</p>
<p>Ugye tudjuk szintén az előző fejezetből, hogy minden eszköz &quot;agya&quot; egy mikrokontroller. Ez a kicsi és alacsony teljesítményű processzor felelős az adatgyűjtés folyamatának koordinálásáért. Az <em>Arduino</em> fejlesztői platformok mellett tettem le a voksom, mert nem igényel elmélyült hardverismeretet a programozásuk.</p>
<p>Másik fontos alkotóelem, a vezetéknélküli modul. Ebben a választásban már természetesen megszorítás volt, hogy a kiválasztott modul kompatibilis legyen Arduinokkal. Habár nem volt egyszerű döntés, egy <em>nRF24L01+</em> adó-vevő integrált áramkört felhasználó modult választottam.</p>
<p>Ahogy korábban említettem harmadik része az eszközeinknek változó, még pedig az határozza meg, hogy mit szeretnénk elérni az adott szenzorral vagy aktorral. A fejlesztés elején kiválasztottam pár eszköztípust, amit el szerettem volna készíteni és támogatni a kész rendszerben. A teljesség igénye nélkül be fogok mutatni pár szenzor és aktor modult, mint például a hőmérséklet mérésére szolgáló <em>DHT22</em> hő- és légnedvesség mérő szenzor modult.</p>
<p>Mindezek után kitérek arra, hogy a fent említett hardvereket hogyan kell összekötni, hogy egy működő eszközt kaphassunk. Szerencsémre az összerakási folyamat nem igényelt jelentős villamosmérnöki tudást, elég volt néhány kábellel összekötni a megfelelő ki- és bemeneteket.</p>
<h2 id="hardver-választás"><span class="header-section-number">3.1</span> Hardver választás</h2>
<h3 id="arduino"><span class="header-section-number">3.1.1</span> Arduino</h3>
<p>Az Arduino-k egyszerűen használható AVR mikrokontroller alapú fejlesztői platfromok, melyeknek az a céljuk, hogy megkönnyítsék az elektronikával való ismerkedést az átlagemberek számára. Ezeket az eszközöket az Arduino, mint vállalat tervezte, illetve tervezi, hiszen folyamatosan újabb és újabb Arduino platformok kerülnek napvilágra. Az Arduino vállalatnak fő célja az volt az Arduino eszközök tervezésénél, hogy minél több embernek legyen elérhető az elektronikus eszközökkel való barkácsolás. Mindezt úgy próbálják elérni, hogy olcsón előállíthatóak az eszközök, hogy leegyszerűsítették a programozást, illetve, hogy minden hardver tervet nyílt forrásúvá tettek.</p>
<p>Az én választásom is a fent említett előnyök miatt esett az Arduino fejlesztői platformokra. A nyílt források miatt kínai Arduino klónok lepték el a piacot. Akár 1000 forintért<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> is hozzájuthatunk egy ilyen klónhoz, de akár az eredetit is beszerezhetjük szintén nem túl drágán körülbelül 6000 forintért<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> magyarországi internetes boltokból.</p>
<p>A legfontosabb érv számomra mégis az, hogy nagyon egyszerű programozni az Arduinokat. Ezért is figyeltem fel rájuk és töltöm sokszor szabadidőmet Arduinokat használó saját projektekkel. A platformok mellé az Arduino vállalat aktívan fejleszt egy saját programozási környezetet és egy programozási nyelvet is. Az &quot;Arduino&quot; programozási nyelv valójában egy olyan C/C++ könyvtár, amely egyszerűsíti az eszközök használatóhoz kapcsolódó programozási feladatokat. Például ahhoz, hogy egy LED-et villogtassunk elég a következő kód:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="co">// the setup function runs once when you press reset or power the board</span>
<span class="dt">void</span> setup() {
  <span class="co">// initialize digital pin LED_BUILTIN as an output.</span>
  pinMode(LED_BUILTIN, OUTPUT);
}

<span class="co">// the loop function runs over and over again forever</span>
<span class="dt">void</span> loop() {
  <span class="co">// turn the LED on (HIGH is the voltage level)</span>
  digitalWrite(LED_BUILTIN, HIGH);
  <span class="co">// wait for a second</span>
  delay(<span class="dv">1000</span>);                       
  <span class="co">// turn the LED off by making the voltage LOW</span>
  digitalWrite(LED_BUILTIN, LOW);
  <span class="co">// wait for a second</span>
  delay(<span class="dv">1000</span>);                       
}</code></pre></td></tr></table></div>

<p>Továbbá mivel C/C++ az alapnyelv az Arduino &quot;nyelv&quot; támogat minden olyan C vagy C++-beli nyelvi elemet, amit a <code>avr-gcc</code> fordítóprogram támogat.</p>
<h3 id="vezetéknélküli-modulok"><span class="header-section-number">3.1.2</span> Vezetéknélküli modulok</h3>

<h3 id="eszköz-specifikus-hardver"><span class="header-section-number">3.1.3</span> Eszköz specifikus hardver</h3>
<p>Közös megszorítás volt természetesen minden eszköz specifikus modul kiválasztásánál, hogy könnyedén lehessen használni Arduinokkal. Ez általában abban nyilvánult meg, hogy az interneten találtam-e Arduinokhoz írt könyvtárakat, amik az adott modul képességeinek használatát teszik lehetővé. Választási szempontom volt még, hogy mennyire drága az eszköz. Néhol érdemes feláldozni a mérési pontosságot ahhoz, hogy ne kelljen sok pénzt kiadni. Mivel minden eszköztípus más érzékelőt vagy más funkciót elvégző alkatrészt tartalmaz, illetve mivel konkrétan akármilyen funkciójú eszközt megtervezhetünk, ezért nem tudok minden eszköz specifikus modult bemutatni. Viszont korábban említettem, hogy kiválasztottam pár szenzort és aktort, amit megterveztem és támogattam a rendszer fejlesztése során. Ezek a következőek:</p>
<ul>
<li>Hő- és páratartalom szenzor</li>
<li>Mozgásérzékelő szenzor</li>
<li>Föld nedvesség szenzor</li>
<li>Elektromos relé aktor</li>
</ul>
A <em>hő- és páratartalom szenzor</em> elkészítéséhez az úgynevezett <code>DHT22</code> modult használtam, ami egyszerre képes hőmérsékletet és páratartalmat mérni. Eredetileg nem terveztem, hogy egy szenzor akár többféle adatot is tud szolgáltatni a központi rendszernek, de mivel egy ilyen kettő-az-egyben modult találtam, ezért hamar változtattam az eredeti elképzeléseimen. Azért ezt a DHT22 modult választottam, mert szinte csak ehhez találtam Arduinot használó példákat. Pontosságát tekintve a 2%-os páratartalom és 0.5°C-os hőmérséklet hibahatár bőven megfelelt az én céljaimra. A modul ára is aránylag kedvező, hiszen körülbelül 3000 forintért<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> beszerezhető egy-egy darab.

A <em>mozgásérzékelő szenzor</em> elkészítéséhez <code>PIR szenzort</code> használtam. A PIR feloldása a &quot;<em>passive infrared</em>&quot;, vagyis az infravörös fények változását képes érzékelni a szenzor. Ilyen PIR szenzorokat használnak például a mozgásra felkapcsoló kertilámpák is. Ezek egyszerű eszközök, általában működésük annyiból áll, hogy amikor mozgást érzékelnek elindul egy időzítő és az amíg le nem jár, addig a modul magas jelet ad. Ahogy az időzítő lejárt eltűnik a jel. Ennek a jelnek az értelmezése rendkívül egyszerű Arduinokkal. Elég, ha rákötjük a PIR szenzor kimenetét az Arduino egyik bemenetére és figyeljük mikor változik a bemeneten a jel. Az időzítő hossza és a modul érzékenysége kézzel állítható az eszközön. Ahogy az előző esetben is, most se magas az ára egy ilyen modulnak. Körülbelül ezek a szenzor modulok is 3000 forintba<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> kerülnek.

A <em>föld nedvesség szenzor</em> még a <em>mozgásérzékelő szenzornál</em> is egyszerűbb mérőeszközt igényel. A legegyszerűbb módja annak, hogy a föld nedvességét megmérjük az, hogy két föld alá dugott fémlemez között megmérjük a föld ellenállását. Minél kisebb az ellenállás, annál nedvesebb a föld. Ezt az elvet használó érzékelő modulokat könnyedén lehet találni és nem is drágán. Egy-egy ilyen érzékelő ára 1500 forint<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> körül mozog. Ahhoz, hogy működésre bírjük ezeket az eszközöket, szintén csak annyi a dolgunk a kimenetet az Arduino egyik bemenetére kötjük és onnan leolvassuk az ellenállás értékét. Abból tudunk következtetni mennyire száraz vagy nedves a föld.

Az <em>elektromos relé aktor</em> esetében egy 5 voltos relére volt szükségem. Ha magasabb feszültséget igénylő relét akartam volna használni, akkor plusz alkatrészekre lett volna szükségem ahhoz, hogy Arduinoval irányíthassam. Egy relé alapvetően úgy működik, mint egy akármilyen villanykapcsoló, a különbség csak annyi, hogy elektromos jellel lehet kapcsolni. A relé egyik oldalára az irányítani kívánt áramkört kell bekötni, a másikra a mi esetünkben az Arduino egy kimenetét és az említett 5 voltot. Így a kimenet fel- és lekapcsolásával a bekötött áramkört is kapcsolgatjuk. Az ára a reléknek rendkívül változó tud lenni, annak függvényében, hogy mekkora teljesítményt bírnak ki. Én egy 10 ampert kibíró relé mellett döntöttem, ami 2500 forint<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> körüli összegbe kerül.

<h2 id="felépítés"><span class="header-section-number">3.2</span> Felépítés</h2>
<p>Így, hogy minden alkatrészt kiválasztottunk a következő feladat, hogy össze is rakjuk az eszközeinket. Az első és legfontosabb lépés, hogy áramot kapjon a fő alkatrészünk, az Arduino. Magán az Arduinon elhelyezett feszültség szabályzónak köszönhetően, képesek vagyunk akár egy 9V-os elemmel is megoldani az áramellátást. A példa kedvéért most maradjunk ennél a megoldásnál annak okán, hogy ne kelljen fölösleges feszültség átalakításokkal foglalkozni. Valójában úgy terveztem viszont az eszközt, hogy egy tölthető, 3.7V-os lithiumion-akkumulátor üzemeltesse a szenzorjainkat, aktorjainkat.</p>
<p>Ha megoldottuk az áramellátás kérdését, jöhet a kommunikáció felállítása a központi szerverrel. Ehhez az úgynevezett SPI (&quot;<em>Serial Peripheral Interface</em>&quot;) buszt kell használjuk az Arduino és az nRF24L01+ közötti kommunikációhoz. Sajnos magam sem ismerem mélyrehatóan az SPI technológiát, hiszen programtervező informatikusnak tanulok, viszont röviden összefoglalva az SPI egy soros kommunikációs interfész, amely <em>master-slave</em> architektúrára épül. Tehát van egy <em>master</em> eszköz és elviekben tetszőleges számú <em>slave</em>, ahol a <em>master</em> eszköz irányítja teljes egészében a kommunikációt és a <em>slave</em> eszközök csak a <em>master</em> jelére kezdenek el adatot küldeni. Összesen négy kábel elég ahhoz, hogy a kapcsolat létrejöjjön az Arduino és az nRF24L01+ között. Ahogy összekötöttük őket a full-duplex kapcsolaton keresztül máris tudunk adatot küldeni más nRF24L01+-t használó eszközöknek.</p>
<p>Hátra van még az eszköz specifikus rész bekötése. Természetesen ez eszközről eszköre változik, viszont mivel szükség lesz az Arduino megszakítás rendszerére, az egyetlen megszorítás, hogy olyan bemenetre kell bekötni a specifikus eszközt, ahol az Arduino támogatja a megszakításokat. A megszakításokat később, a . alfejezetben fogom ismertetni.</p>
<h3 id="példák-kész-eszközökre"><span class="header-section-number">3.2.1</span> Példák kész eszközökre</h3>
<p>Csak felsorolásszerűen bemutatnám képekben annak a pár eszköznek a felépítését, amelyeket korábban említettem, mint a rendszer által támogatottak. A képek nem feltétlen fedik le a valós, összerakott eszközök felépítését. Ennek oka annyi, hogy másképp nem feltétlen lennének jól értelmezhetőek az ábrák. Például bizonyos esetekben az nRF24L01+ kommunikációs modul nem megfelelő tápfeszültséget kap a képeken, viszont ez nem változtat semmit a valódi bekötési ábra számunkra is lényeges részeihez képest.</p>
<ul>
<li>Hő- és páratartalommérő szenzor
</li>
<li>Mozgásérzékelő szenzor
</li>
<li>Elektromos relé aktor
</li>
</ul>
<h2 id="firmware-működés"><span class="header-section-number">3.3</span> Firmware működés</h2>

<h3 id="megszakítások"><span class="header-section-number">3.3.1</span> Megszakítások</h3>
<p> A fejlesztés közben szembesültem azzal, hogy különbséget kell tegyek szenzorok közt is a kívánt működésüket tekintve. Pontosabban fogalmazva abban különbözhet egyik szenzor a másiktól, hogy mikor kell adatot küldjön a központi szervernek. Gondoljunk bele abba, hogy egy hőmérő szenzor elég, ha fix időközönként elküldi az aktuális állapotát. Ha viszont tegyük fel egy mozgásérzékelő szenzorról beszélünk, akkor azt szeretnénk, hogy ha mozgás van a szobában, akkor egyből elküldje az új adatot a szenzor. Ugyan ez az helyzet például egy ajtózárt irányító aktor esetében is. Azonnal szeretnék értesülni arról, hogy kinyitották a bejárati ajtót, nem pedig akkor, ha éppen úgy esik a fix időközönkénti állapot küldés. A fix időközönként közvetítő szenzort időzített szenzoroknak neveztem el, míg a azokat amik állapotváltozást igényelnek, hogy elküldjék az adatot, reaktív szenzoroknak.</p>
<p>Az eszközök felépítésének bemutatásánál említettem a megszakítások fogalmát és azt, hogy szükségünk lesz rájuk. A megszakítások olyan külső vagy belső jelek, amelyek a feldolgozó egység számára szólnak, hogy azonnali figyelmet igényel valamilyen hardver vagy szoftver. Az Arduinok esetében egy ilyen megszakítás lehet egy bemeneti jel változás vagy esetleg egy belső időzítő lejárta. Másik fontos tulajdonsága a megszakításoknak az Arduinoknál, hogy egy megszakítás hatására az eszköz képes felébredni alvó állapotból. Így viszont meg is oldottuk a szenzorok közti különbség problémáját, hiszen, ha az Arduino normál állapotban van, akkor leolvassuk az aktuális állapotát az eszköznek, elküldjük a központi szerverhez az adatot, majd alvó módba lépünk. Ahhoz, hogy az időzett szenzorok fix időközönként közvetítsenek a belső időzítőt kell használni az eszköz felébresztésére, a reaktív szenzorok esetében egy olyan bemenetre kell kötni az érzékelő modult, ahol az Arduino támogatja a megszakításokat. Így elértük azt, hogy ha például valamilyen mozgást érzékelünk az eszköz egyből felébred és elküldi az új állapotot.</p>
<p>Itt egy picit kitérnék az aktorok működésére is, igaz szorosan nem a szenzor típusokhoz kapcsolódik, viszont a megszakításokhoz annál inkább. Mivel az aktorok nem csak üzennek a központi szervernek, hanem fogadnak is onnan érkező parancsokat, az eszköznek normál állapotában kell működnie ahhoz, hogy a parancsot fel tudja dolgozni. Ennek ellenére szeretnénk, ha az aktorok is tudnának alvó állapotban lenni energiatakarékosság miatt. Szerencsére az nRF24L01+ képes nekünk megszakításokat generálni, ha valamilyen üzenet érkezett az eszköz számára. Ez pont tökéletes számunkra, hiszen csak akkor fogjuk így felkelteni az Arduinot alvó állapotból, ha fel kell dolgozni a központól érkezett parancsot.</p>
<h3 id="alacsony-fogyasztás"><span class="header-section-number">3.3.2</span> Alacsony fogyasztás</h3>
<p>Mindegyik eszköznek, működése folyamán, van olyan időköze, amikor nem kell semmilyen feladatot elvégezzen. Szenzoroknál például két állapot leolvasás közt vagy aktorok esetén két parancs feldolgozás közt. Felmerül a kérdés, hogy amíg nincs szükségünk az eszközök teljes számítási kapacitására, addig tudnánk-e valamilyen módon energiát megtakarítani annak érdekében, hogy kevesebbszer kelljen elemet cserélni bennük. Korábban már említettem, hogy az Arduinok képesek <em>alvó módba</em> lépni és ezzel elérjük azt, hogy spóroljon az energiával. Ha például a legalacsonyabb energiafelhasználású módba tesszük az eszközt akár 40-szer kevesebb áramot fogyaszthat az Arduinon elhelyezett AVR mikrokontroller. Ez viszont jelentős üzemidő javulást jelenthet, így akár pár napnyi működés helyett hónapok is lehetnek. Lehetőségünk van még arra is, hogy kikapcsoljuk az AVR mikrokontroller nem használt részeit. Kikapcsolhatjuk például az analóg-digitális átalakítót vagy bizonyos belső időzítőket. Alkalmazhatjuk például úgy ezt a módszert, hogy mielőtt alvó módba lép az eszköz kikapcsoljuk minden részét a mikrokontrollernek és majd csak akkor visszakapcsoljuk azokat, ha felébred. Illetve azokat a részeket véglegesen kikapcsolhatjuk, amik olyan funkciókért felelnek, amiket sose használunk.</p>
<p>Tovább tudjuk faragni a fogyasztást bizonyos hardveres módosításokkal. Minden Arduinon található egy LED, ami folyamatosan ég amíg az eszköz áramot kap. Ha ezt a LED-et eltávolítjuk szintén jelentős mennyiségű energiát megspórolhatunk és igazából szükségünk sincs arra a jelző fényre. Található még az Arduinokon egy feszültség szabályzó integrált áramkör, ami általában nem a legjobb hatékonysággal rendelkezik. Természetesen ennek az az oka, hogy ahol csak lehet az olcsóbb alkatrészeket választják a gyártási költségek minimalizálása miatt. A feszültség szabályzó cseréje egy hatékonyabbra szintén segíthet valamennyit. Akár a teljes eltávolítása is megoldás lehet még, csak sajnos a mi esetünkben szükség van rá, így ez nem járható út.</p>
<h1 id="hálózati-réteg-1"><span class="header-section-number">4</span> Hálózati réteg</h1>
<p>Az áttekintő fejezeteben említésre került, hogy miért van szükség a hálózati rétegre. Ez a mondhatni közvetítő réteg annak ellenére, hogy nem végez el sok funkcionalitást, mégis sok munkát igényelt a fejlesztés során. A nehézség nem feltétlen csak a szoftver előállításából adódott, hanem a megfelelő hardverek megtalálásából és azok összehangolásából. Ahhoz, hogy fogadni tudjuk az eszközök üzeneteit ugyanolyan <em>nRF24L01+</em> adó-vevő modult kell használni a hálózati rétegben is, mint az eszközökben. Mivel az ahhoz való kapcsolódás és kommunikáció alacsony szintű hardverhozzáférést igényel és SPI buszt egy hétköznapi számítógép nem megfelelő számunkra. Léteznek viszont úgynevezett <em>single-board</em> számítógépek, amelyek pont az ilyen esetekre lettek kitalálva. Egy-egy ilyen számítógépen található egy aránylag nagy teljesítményű processzor, pár megszokott ki- és bemenet perfirériák számára (pl.: USB portok) és ami a legfontosabb számunkra GPIO pinek vagy másnéven <em>általános-célú ki- és bemenetek</em>. A GPIO-n keresztül lesz lehetőségünk az adó-vevő modullal kommunkálni. Az én választásom a <em>Raspberry Pi 3</em> apró számítógépre esett.</p>
<p>Szó lesz még a fentiek mellett a hálózat felépítéséről, hogy miként is kapcsolódnak és kapnak címet az eszközök. Habár mindezt az <em>nRF24L01+</em> modulhoz fejlesztett külső programkönyvtár végzi, mégis jelentős részét képezi a hálózati réteg működésének. A hálózat maga <em>mesh alapú</em>, viszont ez csak a programkönyvtárnak köszönhető, ezért nevezném inkább <em>pszeudo-mesh</em> hálózatnak, amit meg is fogok magyarázni miért. Ha már tudjuk, hogyan kapcsolódunk a hálózathoz, akkor már csak az üzenetek küldése hiányzik. Ismertetni fogom, hogy milyen felépítésűek az állapot jelentő vagy állapot beállító üzenetek a szerver és hálózati réteg között, illetve a hálózati réteg és az eszközök között.</p>
<p>Ezek után röviden bemutatom, hogy miként is épül fel a hálózati réteg szoftvere, hogy hol voltak gondjaim a fejlesztés során. Illetve említésre kerül még a C++ <em>Boost</em> könyvtárcsomag, mivel rendkívül megkönnyítette számomra a TCP kapcsolat kezelését a központi szerverrel.</p>
<h2 id="mesh-hálózat"><span class="header-section-number">4.1</span> Mesh hálózat</h2>
<p>Ahogy említettem a teljes eszköz hálózat irányítását egy külső programkönyvtár végzi. Elvégez olyan feladatokat, mint például az automatikus címkiosztás vagy éppen az útkeresés két eszköz között az üzenetküldéshez. Ezeknek köszönhetően az eszközök automatikusan be tudnak csatlakozni a hálózatba, annak bármely pontján és el tudnak érni bármilyen eszközt, ami aktív része a hálózatnak. Ezáltal a végfelhasználónak nem kell konfigurációval foglalkoznia a hálózat miatt, hiszen minden eszköz miután bekapcsoltuk saját maga végzi el a szükséges feladatokat, ahhoz, hogy a hálózathoz csatlakozhasson. Ezt a programkönytárat a <em>TMRh20</em> névre hallgató GitHub felhasználó készítette el és az <em>RF24Mesh</em> nevet adta neki,<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> amely az <em>nRF24L01+</em> adó-vevő modullal való munkát könnyíti meg.</p>
<h3 id="felépítés-1"><span class="header-section-number">4.1.1</span> Felépítés</h3>
<p> A <em>mesh</em> hálózatok legfontosabb tulajdonságai közé tartozik, hogy minden csomópontja a hálózatnak résztvesz az adatforgalom továbbításában, illetve, hogy a hálózat maga oldja meg az esetleges kapcsolati problémák okozta hálózati elérhetetlenséget. Mindez úgy valósulhat meg, hogy a csomópontok között akár több útvonal is létezik és ha egy csomópont elérhetetlenné válik, akkor újrakonfigurálja magát, hogy a hálózat másik pontján csatlakozhasson fel újra.</p>
<p>A felszínről nézve egy <em>mesh</em> hálózatot kapunk az <em>RF24Mesh</em> segítségével összekapcsolt eszközök csoportjából. Azonban a belső működés egy <em>fa-alapú</em> hálózatra épít és azt dinamikusan alakítva kapjuk meg a <em>mesh</em> hálózatot. Ezen működésnek nagy árulkodó jele például, hogy szükség van egy központi csomópontra, ahhoz, hogy a címkiosztás működjön. Ezen ok miatt neveztem <em>pszedo-mesh</em>-alapúnak a hálózatot a fejezet elején. Sajnos annak, hogy fa-alapra épül valójában a hálózatunk vannak következményei. A fa topológiából adódik, hogy minden eszközt csak egy úton tudunk elérni és ezért elveszítjük a redundás utak előnyeit. Megvan az oka, viszont, hogy miért a fa topológia lett mégis felhasználva a belső működésre. Az <em>nRF24L01+</em> egyszerre összesen 6 kapcsolatot tud fenntartani, tehát, ha több út vezetne egy csomóponthoz, akkor hamar kifogyhatunk abból a 6 kapcsolatból. Ami azt illeti, még így is rendkívül hamar kevésnek tud bizonyulni.</p>
<p>Szerencsénkre nem minden eszköznek kell folyamatosan aktív része lenni a hálózatnak. Mivel az összes szenzor csak időszakosan kell rendelkezzen hálózati kapcsolattal, ezért mielőtt alvó módba lépnek lecsatlakozhatnak a hálózatról. Ezt csak azért léphetjük meg, mert a szenzorokat nem akarja elérni egy csomópont se. Ezzel ellentétben az aktoroknál nincs ilyen szerencsénk, hiszen az aktoroknak szólhatnak állapot beállító parancsok.</p>

<h3 id="címzés"><span class="header-section-number">4.1.2</span> Címzés</h3>
<p>Ahogy említettem a központi csomópont kezeli minden egyes hálózati eszköz címének kiosztását, a címek tárolását és a címek feloldását is. Minden eszköznek van egy egyedi, fix, 0-től 255-ig terjedő csomópont azonosítója. Tekinthetünk erre az azonosítóra, akárcsak egy MAC címre. Ezzen azonosító segítségével tudunk majd üzeneteket címezni az adott csomópontnak. Amikor egy csomópont felcsatlakozik a hálózatra a központi csomópont kioszt neki egy hálózati címet, amelyet el is ment magának. A hálózati cím már viszont az IP címekhez hasonlítható. Közvetlen üzenetet küldeni csak a hálózati cím birtokában tudunk. Az automatikus cím kiosztás úgy működik, hogy az újonnan csatlakozott csomópont egy kérést indít a központ felé. A központ mindig a 0-ás csomópont azonosítóval rendelkezik, így az újonnan kapcsolódott csomópont is tudhatja hova kell küldeni a címkérést. Ez nem csak a címkérésnél érvenyes természetesen, ha akármilyen üzenetet szeretnénk küldeni a központi csomópontnak akkor csak a 0-ás címnek kell címezni az üzenetet. Azonban, ha a címzett nem a központi csomópont, akkor szükséges egy kérést intézni a központi csomóponthoz, hogy lekérjük a csomópont azonosítóhoz tartozó hálózati címet, majd a megkapott hálózati címre elküldhetjük az üzenetet.</p>
<h2 id="üzenetek-felépítése"><span class="header-section-number">4.2</span> Üzenetek felépítése</h2>
<p>A hálózati réteg legfontosabb funkciója, hogy átalakítsa az üzeneteket megfelelő formátumra a központi szerver és az eszközök között. Erre azért van szükség, mert míg a központi szerverrel egy TCP kapcsolaton keresztül JSON üzenetekkel kommunikálunk, addig az eszközökkel nyers bitfolyamokon keresztül C-beli <code>struct</code>-okat használva tudunk. Egy üzenet típusa vagy állapot jelentés vagy állapot beállítás lehet.</p>
<p>Az üzenetekben használt csomópont azonosító megegyezik a . alfejezet csomópont azonosítóival. Az adat típus sztring literálok megmondják, hogy az adott eszköz milyen specifikus hardverrel rendelkezik, például a <code>temperature</code> adat típust a hőmérő szenzor használja. Fontos még megemlíteni, hogy logikusan az állapot jelentő üzenetek mindig egy eszköztól indulnak és az állapot beállító üzenetek mindig a központi szervertől.</p>
<h3 id="kommunkáció-a-központi-szerverrel"><span class="header-section-number">4.2.1</span> Kommunkáció a központi szerverrel</h3>
<p>Azért esett a választásom a TCP kapcsolaton keresztüli kommunikációra a központi szerver és a hálózati réteg közt, mert jelentősen egyszerűbb megoldani, mint más technológiákkal. Például megoldás lett volna még, hogy közös megosztott memória területen dolgozzon a központi szerver és a hálózati réteg. A hátránya az lett volna az osztott memóriának, hogy kötelező egy eszközön futnia a kapcsolat mindkét felének. Hasonló indokok állnak a mögött is, hogy miért JSON-t választottam az üzenetek formai alapjának. Szintén ez volt a legkönnyebben és leghamarabb megvalósítható megoldás. Habár itt már voltak más életképes megoldások is, mint például a Google által fejlesztett <em>Protobuf</em>, ami egy programozási nyelvfüggetlen adatcsere formátum. A JSON, azért tűnt mégis jobbnak számomra, mert könnyebben tudtam változtatni az üzenetek formátumán és kevesebb velejáró programozást igényelt.</p>
<ul>
<li><p>Állapot jelentés üzenet:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="dt">id</span><span class="op">:</span> [csomópont azonosító]<span class="op">,</span>
  <span class="dt">type</span><span class="op">:</span> [adat típusa]<span class="op">,</span>
  <span class="dt">value</span><span class="op">:</span> [adat érték]<span class="op">,</span>
  <span class="dt">category</span><span class="op">:</span> [aktor vagy szenzor]
<span class="op">}</span></code></pre></div></li>
<li><p>Állapot beállító üzenet:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="dt">id</span><span class="op">:</span> [csomópont azonosító]<span class="op">,</span>
  <span class="dt">targetState</span><span class="op">:</span> [kívánt állapot]
<span class="op">}</span></code></pre></div>
<h3 id="kommunkáció-az-eszközökkel"><span class="header-section-number">4.2.1</span> Kommunkáció az eszközökkel</h3>
<p>Több különbség is észrevehető a központi szerver üzeneteihez képest. Elsőnek azt láthatjuk meg, hogy sehol nincs <code>id</code> mező, de nincs is rá szükség, mivel az üzenetet csak <code>id</code> csomópont azonosítóval rendelkező eszköznek küldjük el. Második különbség, hogy nincs <code>category</code> mező az állapot jelenő üzenetben. Erre azért nincs szükség, mert a hálózati kapcsolatot irányító programkönyvtár megengedi, hogy felcimkézzük az üzeneteket. Ezt kihasználva minden eszköz, mivel tudja magáról, hogy melyik kategóriába tartozik megfelelően cimkézi az üzeneteket. Ez a cimke lesz átalakítva mezővé a központi szervernek küldött üzenetekben.</p></li>
<li><p>Állapot jelentés üzenet:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> state_update_message {
  <span class="dt">float</span> data; <span class="co">// adat érték</span>
  <span class="dt">char</span> type[<span class="dv">15</span>]; <span class="co">// adat típus</span>
};</code></pre></div></li>
<li><p>Állapot beállító üzenet:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> state_set_message {
  <span class="dt">float</span> targetState; <span class="co">// kívánt állapot</span>
};</code></pre></div></li>
</ul>
<h2 id="raspberry-pi"><span class="header-section-number">4.3</span> Raspberry Pi</h2>
<p>A <em>Raspberry Pi</em> eszközcsalád rendkívül nagy hírnevet szerzett a <em>single-board</em> számítógépek világában. Mára, akit érdekel az IoT vagy az otthoni elektronikai barkácsolás, az bizonyára hallott a <em>Raspberry Pi</em> eszközcsalád egyik tagjáról. Jelenleg a legnagyobb teljesítménnyel a <em>Raspberry Pi 3</em> rendelkezik. Azon kívül, hogy a nagy gyártói és közösségi támogatás miatt nagyon egyszerű ezeket az eszközöket felhasználni saját projektjeinkben, még nagyon jó áron is hozzájuk juthatunk. Akár Magyarországon is 15000 forintért<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> kézhez kaphatunk egy <em>Pi 3</em>-at. Léteznek viszont olcsóbb testvérek is a <em>Pi 3</em>-hoz képest. Vegyük például a <em>Raspberry Pi Zero W</em>-t, ami úgy híresült el, mint az első 5 amerikai dollárba kerülő számítógép a világon. Azaz átszámolva 1500 forint környékén hozzájuthattunk egy olyan hardverhez, ami képes futtatni egy könnyedebb Linux disztribúciót és akár mindennapi irodai munkát is el lehet végezni rajta. Pontosan a fenti okok győztek meg arról, hogy nekem is egy ilyen eszközt kell használjak a hálózati réteg futtatásához. Illetve az is fontos döntési pont volt, hogy az általam választott <em>RF24Mesh</em> programkönyvtár teljes mértékben támogatja a <em>Raspberry Pi</em>-t.</p>
<h3 id="használat"><span class="header-section-number">4.3.1</span> Használat</h3>
<p>A <em>Raspberry Pi 3</em> annak ellenére, hogy olcsón van árazva, aránylag jó hardver konfigurációval rendelkezik. A központban egy <em>ARMv8</em> architektúrájú 64 bites processzor van, amely 4 darab 1.2GHz-es magból van felépítve. A processzor mellé 1 GB RAM van párosítva, amely bőven elég a legtöbb felhasználási módra. Mindemellett WiFi 802.11n és Bluetooth 4.1 LE képes az eszköz.</p>

<p>Ahhoz, hogy elkezdhessük használni szükségünk lesz egy SD kártyára, egy 5 voltos áramforrásra, egy HDMI képes monitorra és billentyűzetre, egérre. Az első lépés, hogy egy másik számítógéppel feltelepítsünk egy Linux disztribúciót az SD kártyára. Ajánlott magához a <em>Pi</em>-hez készített <em>Raspbian</em> Linuxt feltenni. Ha bele dugtuk az összes perifériát és az SD kártyát a <em>Pi</em>-be, majd áram alá helyezzük rövid időn belül egy teljes Linuxos felület fogad minket.</p>
<h3 id="raspberry-pi-foundation"><span class="header-section-number">4.3.2</span> Raspberry Pi Foundation</h3>
<p>A <em>Pi</em> eszközcsalád mögött a <em>Raspberry Pi Foundation</em> brit jótékonysági szervezet áll. Az a céluk ezeknek a csodás eszközöknek a tervezésével, hogy olyan helyekre is eljuthasson a világon a technológia és annak tanítása, ahova pénzügyi okok miatt amúgy nem tudna. Rendkívül nagy sikerre tettek szert, hiszen több mint 10 millió <em>Pi</em> lett már értékesítve a világon és olyan cégekkel léptek partneri kapcsolatba, mint például a Microsoft. A sok munka, amit a platform fejlesztésével töltenek, viszont nem csak a világ szegényebb részeit segíti. Mivel ezek az eszközök egyszerűen használhatók, olcsóak és ráadásul nagy közösséget is tudott maga mögé állítani, akárki neki tud állni valamilyen elektronikai projektnek szabadidejében.</p>
<h2 id="szoftver-működés"><span class="header-section-number">4.4</span> Szoftver működés</h2>
<p>A hálózati réteg működése könnyen átlátható és annál is egyszerűbben implementálható. A fejezet korábbi részei alapján magától értetődő, hogy a program egyszerre kell kezeljen egy vezeték nélküli kapcsolatot az eszközökkel és egy TCP kapcsolatot a központi szerverrel. Ha ezt a két feladatot egy futattási szálon szeretnénk elvégezni nagy eséllyel gondokba ütköznénk, aminek az lenne az oka, hogy az egyik kapcsolat eseményei nem lennének kellően lekezelve, amíg a másik kapcsolat kapja a figyelmet. Példa eset, az egyik kapcsolaton keresztül épp olvasás történik és a másikon üzenet érkezik. Viszont ez még nem azt jelenti, hogy a feladat megcsinálhatatlan egy futási szálon. Bizonyára lehetséges, de én úgy döntöttem, hogy teljesítményi okokból inkább kettő szálon kezelem a kapcsolatokat. A futtató hardverünk nem fog gátakat szabni e szempontból, tehát nyugodtan használhatunk szálkezelést.</p>

<p>Van akkor két végrehajtási szálunk, egy a TCP kapcsolatnak, egy a vezeték nélküli kapcsolatnak. Ha akármelyiken valamilyen üzenet érkezik, azt át kell alakítani a másik fél üzenetformájára és azon az oldalon tovább küldeni. Figyelnünk kell viszont, mivel ha az egyik szál közvetlen bele szól a másik oldal kapcsolatába, könnyen lehet, hogy elrontja a kapcsolatot. Ami azt illeti elsőnek elvétettem ezt a hibát és nem is működött túl megbízhatóan a rendszer. Megoldani a problémát nem volt nehéz, hiszen elég volt mindkét szálon létrehozni egy listát, amelyben ideiglenesen el lesznek tárolva azok az üzenetek, amiket majd el kell küldeni. Vagyis, ha az egyik szálon érkezik egy üzenet, átalakítja azt, majd belerakja a másik szál listájába. Mikor a másik szál oda kerül, hogy üzeneteket küld, akkor kiveszi a listából a várakozó üzeneteket és kézbesíti. A listához való hozzáadás mindig lezárja a hozzáférést a másik oldal számára, így az csak akkor tudja olvasni és elküldeni az üzeneteket, ha senki nem ad hozzá éppen semmit. Ezzel így teljes mértékben megoldottuk a szálkezelést és minden üzenet szinte azonnal kerül kézbesítésre.</p>
<h3 id="programkönyvtárak"><span class="header-section-number">4.4.1</span> Programkönyvtárak</h3>
<p>Említésre került a fejezet elején, hogy a <em>Boost</em> könyvtárcsomag egy részét használtam a TCP kapcsolat irányítására. A <em>Boost.Asio</em> programkönyvtár adatok aszinkron feldolgozására van fejlesztve és többek között képes <code>socket</code>-ek kezelésére is. Mivel a <em>Boost</em> könyvtárcsomag, olyan nagy jelentősséggel bír a C++ fejlesztésben, hogy szinte egy kiterjesztett Standard könyvtárként lehet tekinteni rá, egyértelmű választás volt, mint TCP kapcsolatkezelő könyvtár. Jelentős könnyebbséget hoz a C-beli <code>socket</code> programozáshoz képest. Ahhoz, hogy teljesítse a feladatát a TCP kapcsolat kezelő végrehajtási szálunk elsőnek azt kell megnéznie, hogy van-e beérkező üzenetünk a központi szervertől. Ha van, akkor addig olvassuk a bejövő adatot, amíg nem találkozunk egy sorvége karakterrel, mert így jelöltem az üzenet végét. Ehhez a <code>boost::asio::read_until()</code><a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a> függvényt használtam. A beérkezett üzenetet átfuttatva az átalakító logikánkon belerakjuk a vezeték nélküli kapcsolatot kezelő szál listájába. Ha mindez meg volt vagy esetleg nem is volt beérkező üzenet, akkor megpróbáljuk elérni a saját elküldendő üzenet listánkat. Ennek sikere attól függ, hogy éppen történik-e módosítása a listának. Sikeres elérés esetén végig megyünk a listán és egyenként elküldünk minden üzenetet. A küldést a <code>boost::asio::ip::tcp::socket.write_some()</code><a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a> függvény segítségével lehet megvalósítani.</p>
<p>A fenti logikához képest csak egy kicsivel van több dolga a vezeték nélküli kapcsolatot kezelő végrehajtási szálnak. Az előző alfejezetekből tudhatjuk már, hogy az eszközökkel való kommunikáció az <em>RF24Mesh</em> programkönyvtárnak köszönhető. A különbség a másik oldalhoz képest annyi, hogy az <em>RF24Mesh</em> esetén az érkező üzenetek beolvasását megbonyolítja az üzenetek cimkézése. Már említettem, hogy ezeket a címkéket arra használjuk, hogy az eszközök kategóriáját (szenzor vagy aktor) meg tudjuk mondani. A beolvasás azzal kell kezdődjön, hogy megnézzük, milyen címkével rendelkezik az üzenet. Ez úgy történik, hogy az <code>RF24Network::peek()</code><a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a> függvény egy <code>RF24NetworkHeader</code> objektumba belerakja az üzenet fejléc részét. A fejléc rész olyan információkat tartalmaz, mint a küldő és a címzett hálózati címe, egy üzenet azonosító és az üzenet címke. Ezután a <code>RF24Network::read()</code><a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a> függvény a fejléc segítségével az teljes üzenetet belerakja egy általunk megadott változóba. Az olvasás befejezése után minden a TCP kapcsolat kezeléséhez hasonlóan zajlik, csak az üzenetküldéshez a <code>RF24Mesh::write()</code><a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a> függvényt kell használni.</p>
<h1 id="központi-rendszer"><span class="header-section-number">5</span> Központi rendszer</h1>
<h2 id="adatbázis"><span class="header-section-number">5.1</span> Adatbázis</h2>

<h3 id="adatbázis-kiválasztása"><span class="header-section-number">5.1.1</span> Adatbázis kiválasztása</h3>
<h3 id="tárolási-séma"><span class="header-section-number">5.1.2</span> Tárolási séma</h3>
<h2 id="keretrendszerek"><span class="header-section-number">5.2</span> Keretrendszerek</h2>
<h3 id="spring-boot"><span class="header-section-number">5.2.1</span> Spring Boot</h3>
<h3 id="vaadin"><span class="header-section-number">5.2.2</span> Vaadin</h3>
<h2 id="flow-rendszer-1"><span class="header-section-number">5.3</span> Flow rendszer</h2>
<p> Ezek az úgynevezett &quot;flow&quot;-k olyanok akárcsak egy-egy szabály. Olyan szabályok melyeknek van egy feltétele és egy hatása. Egy flow akkor lép életbe, ha a hozzátartozó feltétel a rendszer éppen aktuális állapota mellett teljesül. Ekkor a flow hatása végrehajtódik a rendszer által.</p>
<p>A feltétel része lehet egyes eszközök állapotára vonatkozó megszorítások (pl.: 20°C-nál nagyobb a hőmérsékletet mutat a nappaliban elhelyezett hőmérő), a felhasználó vagy külső rendszer által indított kérés az alkalmazáshoz (pl.: gomb nyomás a kezelőfelületen vagy HTTP kérés egy bizonyos címen), egyéb rendszer állapot feltétel (pl.: időponthoz kötődő feltétel) és ezeknek logikai ÉS-sel összekötött kombinációja. A hatása egy flow-nak állhat eszközök állapotának módosításából, más rendszerhez történő kérésből és egyéb segéd akciókból (pl.: késleltetés). Ezeknek a &quot;hatás elemeknek&quot; egymás után történő végrehajtása adja az adott flow hatását.</p>
<p>A rendszer célja az, hogy a fenti flow-k segítségével a felhasználó szabályokat/feladatokat tud leírni, amelyeket a rendszer majd végrehajt. Így tehát lehetséges bizonyos házkörüli dolgok automatizálása.</p>
<p>Pár példa a rendszer használatára:</p>
<ul>
<li>ha adott szobában nincs érzékelt mozgás, akkor lekapcsolódik a villany</li>
<li>ha több hőmérő is alacsony értéket mutat, akkor automatikusan fentebb megy a fűtés</li>
<li>ha egy virág földje kiszáradna, akkor víz engedődik a virág alatt</li>
<li>ha reggeli időpont van, akkor beindul a kávéfőző</li>
<li>ha a levegő szén-monoxid tartalma átlép egy határt, akkor elindul egy jelző berendezés</li>
<li>ha besötétedik és van mozgás, akkor a sötétítők leengednek és felkapcsol egy villany</li>
</ul>
<h3 id="flow-kiértékelés"><span class="header-section-number">5.3.1</span> Flow kiértékelés</h3>
<h1 id="teljesítmény"><span class="header-section-number">6</span> Teljesítmény</h1>

<h2 id="hatótáv"><span class="header-section-number">6.1</span> Hatótáv</h2>
<h2 id="eszköz-szám"><span class="header-section-number">6.2</span> Eszköz szám</h2>
<h2 id="áteresztőképesség"><span class="header-section-number">6.3</span> Áteresztőképesség</h2>
<h1 id="biztonság"><span class="header-section-number">7</span> Biztonság</h1>
<h2 id="megbízott-eszközök"><span class="header-section-number">7.1</span> Megbízott eszközök</h2>
<h2 id="titkosítás"><span class="header-section-number">7.2</span> Titkosítás</h2>
<h2 id="problémák"><span class="header-section-number">7.3</span> Problémák</h2>
<h1 id="összefoglalás"><span class="header-section-number">8</span> Összefoglalás</h1>
<p>Rengeteg eszköztípus van, amit még meg lehetne valósítani és meg is szeretnék még. Néhány példa:</p>
<ul>
<li>Légnyomásmérő szenzor</li>
<li>Eső érzékelő szenzor</li>
<li>Fény érzékelő szenzor</li>
<li>Szén-monoxid érzékelő szenzor</li>
<li>Ablaksötétítő aktor</li>
</ul>

<!--
Do not edit this page.

References are automatically generated from the BibTex file (References.bib)

...which you should create using your reference manager.
-->
<h1 id="irodalomjegyzék" class="unnumbered">Irodalomjegyzék</h1>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ezt az elnevezést magam adtam, mivel nem találkoztam kutatásaim során más megfelelő elnevezéssel.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Arduino Uno klón: <a href="https://tinyurl.com/ArduinoUnoClone" class="uri">https://tinyurl.com/ArduinoUnoClone</a> (2017. április 11.)<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Eredeti Arduino Uno Magyarországon: <a href="https://tinyurl.com/ArduinoUnoHun" class="uri">https://tinyurl.com/ArduinoUnoHun</a> (2017. április 11.)<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>DHT22 hő- és páratartalom érzékelő: <a href="https://www.adafruit.com/product/385" class="uri">https://www.adafruit.com/product/385</a> (2017. április 11.)<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>PIR mozgásérzékelő: <a href="https://www.adafruit.com/product/189" class="uri">https://www.adafruit.com/product/189</a> (2017. április 11.)<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Föld nedvességmérő: <a href="https://www.sparkfun.com/products/13322" class="uri">https://www.sparkfun.com/products/13322</a> (2017. április 11.)<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Elektromos relé: <a href="https://www.sparkfun.com/products/13815" class="uri">https://www.sparkfun.com/products/13815</a> (2017. április 11.)<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>TMRh20 RF24Mesh programkönyvtárja: <a href="https://github.com/nRF24/RF24Mesh" class="uri">https://github.com/nRF24/RF24Mesh</a><a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Raspberry Pi 3 magyarországi ár: <a href="https://malnapc.hu/yis/raspberry-pi-3-model-b" class="uri">https://malnapc.hu/yis/raspberry-pi-3-model-b</a> (2017. április 13.)<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>Boost::asio::read_until() függvény dokumentáció: <a href="https://tinyurl.com/BoostReadUntil" class="uri">https://tinyurl.com/BoostReadUntil</a><a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>Boost::asio::ip::tcp::socket.write_some() függvény dokumentáció: <a href="https://tinyurl.com/BoostWriteSome" class="uri">https://tinyurl.com/BoostWriteSome</a><a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>RF24Network::peek() függvény dokumentáció: <a href="https://tinyurl.com/RF24Peek" class="uri">https://tinyurl.com/RF24Peek</a><a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>RF24Network::read() függvény dokumentáció: <a href="https://tinyurl.com/RF24Read" class="uri">https://tinyurl.com/RF24Read</a><a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>RF24Mesh::write() függvény dokumentáció: <a href="https://tinyurl.com/RF24Write" class="uri">https://tinyurl.com/RF24Write</a><a href="#fnref14">↩</a></p></li>
</ol>
</div>
            </body>
</html>

